<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta content="width=device-width, initial-scale=1" name="viewport"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/4c8683b68ee63581.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4c8683b68ee63581.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-48f60119be4ac274.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-83cebdb887f48834.js" defer=""></script><script src="/_next/static/chunks/pages/_app-58faad4d000e90d8.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5B...id%5D-de3fe8db1cd8e4ba.js" defer=""></script><script src="/_next/static/LQ_N8afeaVmFBDb_CzQcG/_buildManifest.js" defer=""></script><script src="/_next/static/LQ_N8afeaVmFBDb_CzQcG/_ssgManifest.js" defer=""></script></head><body class="bg-white text-black antialiased dark:bg-gray-900 dark:text-white"><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><div class="flex min-h-screen flex-col justify-between"><nav class="w-full flex items-center border-b justify-between px-4 py-4 backdrop-blur dark:bg-transparent fixed shadow"><div><a aria-label="üë®‚Äçüíª" href="/"><div class="flex items-center justify-between"><div class="font-title fonthidden text-xl md:text-2xl xl:text-3xl font-semibold sm:block">üë®‚Äçüíª</div></div></a></div><div class="flex items-center text-base leading-5"><div class="hidden sm:block"><a class="font-title p-1 text-xl md:text-xl xl:text-2xl font-medium text-gray-900 dark:text-gray-100 sm:p-4" href="/blog"> <!-- -->Blog<!-- --> </a><a class="font-title p-1 text-xl md:text-xl xl:text-2xl font-medium text-gray-900 dark:text-gray-100 sm:p-4" href="/tags"> <!-- -->Tags<!-- --> </a><a class="font-title p-1 text-xl md:text-xl xl:text-2xl font-medium text-gray-900 dark:text-gray-100 sm:p-4" href="/projects"> <!-- -->Projects<!-- --> </a><a class="font-title p-1 text-xl md:text-xl xl:text-2xl font-medium text-gray-900 dark:text-gray-100 sm:p-4" href="/about2"> <!-- -->About<!-- --> </a></div><div class="sm:hidden"><button type="button" class="ml-1 mr-1 h-8 w-8 rounded py-1" aria-label="Toggle Menu"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="text-gray-900 dark:text-gray-100"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg></button><div class="fixed top-0 left-0 z-10 h-full w-full transform bg-gray-200 opacity-95 duration-300 ease-in-out dark:bg-gray-800 translate-x-full"><div class="flex justify-end"><button type="button" class="mr-5 mt-11 h-8 w-8 rounded" aria-label="Toggle Menu"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="text-gray-900 dark:text-gray-100"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><nav class="fixed mt-8 h-full"><div class="px-12 py-4"><a class="text-2xl font-title tracking-widest text-gray-900 dark:text-gray-100" href="/blog">Blog</a></div><div class="px-12 py-4"><a class="text-2xl font-title tracking-widest text-gray-900 dark:text-gray-100" href="/tags">Tags</a></div><div class="px-12 py-4"><a class="text-2xl font-title tracking-widest text-gray-900 dark:text-gray-100" href="/projects">Projects</a></div><div class="px-12 py-4"><a class="text-2xl font-title tracking-widest text-gray-900 dark:text-gray-100" href="/about2">About</a></div></nav></div></div></div></nav><main class="prose dark:prose-dark mx-auto max-w-3xl px-4 sm:px-6 xl:max-w-5xl xl:px-0 py-20"><!--$--><div><div class="fixed right-8 bottom-8 hidden flex-col gap-3 md:hidden"><button aria-label="Scroll To Top" type="button" class="rounded-full bg-gray-200 p-2 text-gray-500 transition-all hover:bg-gray-300 dark:bg-gray-700 dark:text-gray-400 dark:hover:bg-gray-600"><svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3.293 9.707a1 1 0 010-1.414l6-6a1 1 0 011.414 0l6 6a1 1 0 01-1.414 1.414L11 5.414V17a1 1 0 11-2 0V5.414L4.707 9.707a1 1 0 01-1.414 0z" clip-rule="evenodd"></path></svg></button></div><div class="border-b border-gray-200 dark:border-gray-700 text-center"><div><h1 class="text-4xl font-extrabold leading-9 tracking-tight text-gray-900 dark:text-gray-100 sm:text-4xl sm:leading-10 md:text-5xl md:leading-14 break-words">Industrial Networks Lab Notes</h1></div><div><a class="mr-4 text-mm font-medium uppercase text-primary-500 hover:text-primary-600 dark:hover:text-primary-400" href="/tags/school">school</a><a class="mr-4 text-mm font-medium uppercase text-primary-500 hover:text-primary-600 dark:hover:text-primary-400" href="/tags/networks">networks</a></div></div><p>Evaluating, configuring and installing networks in the industry. Configure device networks, field networks and industrial ethernet using PLC&#x27;s and HMI&#x27;s. Requires knowledge of industrial networks and automation.</p>
<hr/>
<h1>GRAFCET</h1>
<p>GRAFCET (Graphe Fonctionnel de Commande Etape Transition) is a programming language designed for industrial control systems based around stages and stage transitions. Created in 1977 by AFCET to bring non digital tools like organization charts, organiphase, Girard diagrams, Petri net and others into PC&#x27;s. Standardized in 1979 by ADESA and internationally in 1992 as CEI1131 and EN61131. For the most part it has been superseded by Ladder Language but it is still a powerful educational and modeling tool.</p>
<p><strong>Sequential or Combinational</strong></p>
<p>A process can be sequential or combinational. Combinational systems have outputs that only depend on the inputs, outputs are independent of the initial state and their transfer functions are logical in nature (AND, OR and NOT). In sequential systems outputs are dependent on the inputs and the previous stages stored in memory as <em>State Variables</em>.</p>
<p><strong>Stages and Transitions</strong></p>
<p>GRAFCET, as an automation system abstraction, doesn&#x27;t know the specific system components, it simply knows that stages represent actions (operations) and transitions represent comparisons (control). GRAFCET stages must be elementary, meaning that in order to  execute a complex operation (macrostage) you must subdivide its actions into their fundamental components. Note that you may need to use as many SET-RESET instructions as there are state variables.</p>
<p><img src="/static/images/notes/SymbolsGrafcetNetworksLab.png" alt="Symbols Used in Grafcet"/></p>
<p>Stages by themselves can be considered purely combinational but by interacting through transitions with other stages we can create sequential systems. Transition&#x27;s logical conditions (boolean algebra) can be as complex as we need them to be in order to continue to the following stage. We can see that each stage has an associated action and each transition has an associated receptive message related to what they will do or compare.</p>
<p><img src="/static/images/notes/ExampleofGraphsNetworksLab.png" alt="Example of Graphs"/></p>
<ol>
<li>Each stage has a boolean stage variable Xi (1 or 0).</li>
<li>Stages can be active or inactive represented by their stage variable (1 is active).</li>
<li>Cold start is an initialization without taking information from memory, meaning that all initial stages are set to active while the rest remain inactive.</li>
<li>Hot start is the reinitialization taking information from memory, meaning that we recover the last known state variables of every stage.</li>
<li>Non-initial stages activate when the previous one was active and its transition condition is met.</li>
<li>A transition can be in one of the following states:<!-- -->
<ol>
<li>Not valid: Immediately preceding or following stage are inactive.</li>
<li>Valid: Immediately preceding or following stage are active but condition is not met.</li>
<li>Passable: Condition has been met and is transferring control to new stage.</li>
<li>Passed: By transferring control the following stage has been activated and the preceding has been deactivated.</li>
</ol>
</li>
<li>If there are multiple passable transitions they will transition simultaneously.</li>
<li>If a stage is activated and deactivated simultaneously it will prefer to remain active.</li>
</ol>
<p><img src="/static/images/notes/CADESIMUSimulationOne.png" alt="Example Program"/></p>
<p><a href="/static/images/files/GRAFCETSimulation1.cad">Download the Example</a></p>
<hr/>
<p><strong>GRAFCET Design</strong></p>
<p><img src="/static/images/notes/GrafcetStagesDesignNetworksLab.png" alt="Stages of GRAFCET"/></p>
<p>First we create a functional GRAFCET defining the general succession of actions and conditions, then we create a sensors and actuators GRAFCET where we specify the components that the automata will use. Finally we translate the GRAFCET into a control system using ladder language.</p>
<p><strong>Control System Design</strong></p>
<p><img src="/static/images/notes/CombinationalSequentialLadderNetworksLab.png" alt="Control Design"/></p>
<p>The translation can be further divided into the sequential ladder translation and the combinational ladder translation. The sequential ladder consists of assigning each stage an internal bit of the PLC representing its internal variable state of active (SET, LATCH) or inactive (RESET, UNLATCH).</p>
<p>The activation or latch of the internal bit of a stage N takes place when previous stages are activate, meaning that every transition condition has been fulfilled. Deactivation or unlatch occurs when a subsequent stage is activated. The combinational ladder consists of executing every action needed within each stage, a logical scheme is obtained detailing the states of every state variable and condition.</p>
<p><strong>Basic Structures</strong></p>
<p>To achieve complex structures like loops, decision making and simultaneous tasks we combine three fundamental structures: Linear sequences, convergence and divergence in OR (alternative threads), and convergence and divergence in Y (parallel threads). One usually starts describing a generic functional graph as a linear sequence and later adding bifurcation (OR and Y) as the complexity of the system increases.</p>
<p><img src="/static/images/notes/CADESIMUSimulationTwo.png" alt="Example Program"/></p>
<p><a href="/static/images/files/GRAFCETSimulation2.cad">Download the Example</a></p>
<p>A linear sequence is simplest structure, consisting of a succession of stages interconnected by transitions. Within a linear sequence only one stage should be active at a given time (simultaneous actions must be done as Y branches). A stage is activated when the previous one is active and the transition condition has been met. Activation of a stage implies the deactivation of the previous one.</p>
<p><img src="/static/images/notes/ORBifurcationNetworksLab.png" alt="OR Bifurcation"/></p>
<p>The OR bifurcation is a structure representing a divergence in OR followed by several possible paths or threads that in the end must converge back to the original macrostructure. This structure is intended as alternative processes that can be executed depending on a logical condition. They are analogous to the if, then, else structure, and therefore must be exclusive of each other when nested.</p>
<p><img src="/static/images/notes/CADESIMUSimulationThree.png" alt="Example Program"/></p>
<p><a href="/static/images/files/GRAFCETSimulation3.cad">Download the Example</a></p>
<p><img src="/static/images/notes/ANDBifurcationNetworksLab.png" alt="AND Bifurcation"/></p>
<p>The AND bifurcation is a structure representing a divergence in AND followed by several threads that will start simultaneously when their common transition condition is met. Every thread must converge back into a single one as they continue their execution but this must be synchronized so that no thread is left behind. It must be avoided to converge AND in an OR convergence. Usually the last stages prior to an AND convergence are waiting for other stages to finish their job.</p>
<p><img src="/static/images/notes/AdditionalStructuresANDORNetworksLab.png" alt="Bifurcation Relation"/></p>
<p>Using AND and OR bifurcations we can create complex relations.</p>
<hr/>
<h1>Sorting Line</h1>
<p>Virtual model of a sorting line. Composed from a storage tower with conveyor chain, a transport band or conveyor belt (both with unidirectional gear motors), three pistons (bidirectional motors) and four discharging tables. This control system has 17 digital inputs and 8 digital outputs. The virtual model can be emulated using a virtual machine within the LabVIEW environment and PLCSim.</p>
<ul>
<li><a href="/static/images/files/CADESIMUPistonsSimuPOne.cad">CADESIMU Pistons</a></li>
<li><a href="/static/images/files/CADESIMUSortingLine.7z">CADESIMU SortingLine</a></li>
<li><a href="/static/images/files/TIASortingLineNoColor.zip">Sorting Line Without Color</a></li>
<li><a href="/static/images/files/TIASortingLineColor.zip">Sorting Line With Color</a></li>
</ul>
<hr/>
<h1>PLC 1200</h1>
<p><img src="/static/images/notes/DataTypesAndBitsNetworksLab.png" alt="Data Types"/></p>
<p>Most PLC input and output addresses use individual bits but you can also reference a group of bits using bytes, words and double words. The range of possible values this groups can have depends on the data type they use (with sign or without sign). Note that only PLC 1500 and forwards can use 64 bit data types.</p>
<table><thead><tr><th align="center">Data Type</th><th align="center">Address</th><th align="center">Bits</th><th align="center">Range Sign</th><th align="center">Range No Sign</th></tr></thead><tbody><tr><td align="center">Bit or Bool</td><td align="center">M0.1</td><td align="center">1</td><td align="center">0 to 1</td><td align="center">0 to 1</td></tr><tr><td align="center">Byte</td><td align="center">MB10</td><td align="center">8</td><td align="center">-128 to 127 (SINT)</td><td align="center">0 to 255 (USINT)</td></tr><tr><td align="center">Word</td><td align="center">MW10</td><td align="center">16</td><td align="center">-32768 to 32767 (INT)</td><td align="center">0 to 65535 (UINT)</td></tr><tr><td align="center">DWord</td><td align="center">MD10</td><td align="center">32</td><td align="center">-2147483648 to 2147483647 (DINT)</td><td align="center">0 to 4294967295 (UDINT)</td></tr><tr><td align="center">LWord</td><td align="center">ML10</td><td align="center">64</td><td align="center">LINT</td><td align="center">ULINT</td></tr></tbody></table>
<p><strong>Set and Reset</strong></p>
<p>We have been setting (S) and resetting (R) bits to control the input and output of the PLC. This can be done more efficiently if we have stablished a state diagram using RS (activation) and SR (deactivation) flipflops.</p>
<table><thead><tr><th align="center">R</th><th align="center">S1</th><th align="center">Q</th><th align="center">S</th><th align="center">R1</th><th align="center">Q</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">Q</td><td align="center">0</td><td align="center">0</td><td align="center">Q</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">O</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr></tbody></table>
<p><strong>Timers</strong></p>
<ol>
<li>TP: Pulse timer when activated it generates a pulse with a set duration.</li>
<li>TON: When activated the output will generate a signal after a set delay.</li>
<li>TOF: When deactivated the output will generate a signal after a set delay.</li>
<li>TONR: When activated the output will generate a signal after a set accumulated delay.</li>
<li>RT: When activated it deletes the time data in the data block of another timer.</li>
</ol>
<p><strong>Counters</strong></p>
<ol>
<li>CTU: Ascending counter.</li>
<li>CTD: Descending counter.</li>
<li>CTUD: Ascending and Descending counter.</li>
</ol>
<p>The CU or CD pulse input increments or decrements the counter by one, the R input resets the counter, the LOAD input sets a new PV input, the PV input is the value needed to activate the counter output, the QU output is true if CVmore than=PV, the QD output is true if CVless than=0 and the CV output is the current counter value. Note that PV and CV can input and output values different than boolean.</p>
<p><strong>Comparators</strong></p>
<p>We can use comparators to compare two values as long as they have the same data type, generally if the comparison is true then the PLC contact will be activated. Valid comparisons include equal, different, greater, less, greater or equal and less or equal.</p>
<p><strong>Scale and Standardize</strong></p>
<p>The <code>SCALE_X</code> instruction scales the real normalized VALUE parameter (0.0 less than= VALUE less than= 1.0) to the data type and range of values specified in the MIN and MAX parameters, therefore OUT = VALUE(MAX-MIN)+MIN. The <code>NORM_X</code> instruction normalizes the VALUE parameter (0.0 less than= OUT less than= 1.0), therefore OUT = (VALUE-MIN)/(MAX-MIN). Note that every parameter (MIN, MAX, OUT, VALUE) must be of the same data type.</p></div><!--/$--></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"toc":[],"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    hr: \"hr\",\n    h1: \"h1\",\n    strong: \"strong\",\n    em: \"em\",\n    img: \"img\",\n    ol: \"ol\",\n    li: \"li\",\n    a: \"a\",\n    ul: \"ul\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    code: \"code\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Evaluating, configuring and installing networks in the industry. Configure device networks, field networks and industrial ethernet using PLC's and HMI's. Requires knowledge of industrial networks and automation.\"\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h1, {\n      children: \"GRAFCET\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"GRAFCET (Graphe Fonctionnel de Commande Etape Transition) is a programming language designed for industrial control systems based around stages and stage transitions. Created in 1977 by AFCET to bring non digital tools like organization charts, organiphase, Girard diagrams, Petri net and others into PC's. Standardized in 1979 by ADESA and internationally in 1992 as CEI1131 and EN61131. For the most part it has been superseded by Ladder Language but it is still a powerful educational and modeling tool.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Sequential or Combinational\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"A process can be sequential or combinational. Combinational systems have outputs that only depend on the inputs, outputs are independent of the initial state and their transfer functions are logical in nature (AND, OR and NOT). In sequential systems outputs are dependent on the inputs and the previous stages stored in memory as \", _jsx(_components.em, {\n        children: \"State Variables\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Stages and Transitions\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"GRAFCET, as an automation system abstraction, doesn't know the specific system components, it simply knows that stages represent actions (operations) and transitions represent comparisons (control). GRAFCET stages must be elementary, meaning that in order to  execute a complex operation (macrostage) you must subdivide its actions into their fundamental components. Note that you may need to use as many SET-RESET instructions as there are state variables.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/static/images/notes/SymbolsGrafcetNetworksLab.png\",\n        alt: \"Symbols Used in Grafcet\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Stages by themselves can be considered purely combinational but by interacting through transitions with other stages we can create sequential systems. Transition's logical conditions (boolean algebra) can be as complex as we need them to be in order to continue to the following stage. We can see that each stage has an associated action and each transition has an associated receptive message related to what they will do or compare.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/static/images/notes/ExampleofGraphsNetworksLab.png\",\n        alt: \"Example of Graphs\"\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Each stage has a boolean stage variable Xi (1 or 0).\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Stages can be active or inactive represented by their stage variable (1 is active).\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Cold start is an initialization without taking information from memory, meaning that all initial stages are set to active while the rest remain inactive.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Hot start is the reinitialization taking information from memory, meaning that we recover the last known state variables of every stage.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Non-initial stages activate when the previous one was active and its transition condition is met.\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"A transition can be in one of the following states:\", \"\\n\", _jsxs(_components.ol, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"Not valid: Immediately preceding or following stage are inactive.\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"Valid: Immediately preceding or following stage are active but condition is not met.\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"Passable: Condition has been met and is transferring control to new stage.\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"Passed: By transferring control the following stage has been activated and the preceding has been deactivated.\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"If there are multiple passable transitions they will transition simultaneously.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"If a stage is activated and deactivated simultaneously it will prefer to remain active.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/static/images/notes/CADESIMUSimulationOne.png\",\n        alt: \"Example Program\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"/static/images/files/GRAFCETSimulation1.cad\",\n        children: \"Download the Example\"\n      })\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"GRAFCET Design\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/static/images/notes/GrafcetStagesDesignNetworksLab.png\",\n        alt: \"Stages of GRAFCET\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"First we create a functional GRAFCET defining the general succession of actions and conditions, then we create a sensors and actuators GRAFCET where we specify the components that the automata will use. Finally we translate the GRAFCET into a control system using ladder language.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Control System Design\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/static/images/notes/CombinationalSequentialLadderNetworksLab.png\",\n        alt: \"Control Design\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The translation can be further divided into the sequential ladder translation and the combinational ladder translation. The sequential ladder consists of assigning each stage an internal bit of the PLC representing its internal variable state of active (SET, LATCH) or inactive (RESET, UNLATCH).\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The activation or latch of the internal bit of a stage N takes place when previous stages are activate, meaning that every transition condition has been fulfilled. Deactivation or unlatch occurs when a subsequent stage is activated. The combinational ladder consists of executing every action needed within each stage, a logical scheme is obtained detailing the states of every state variable and condition.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Basic Structures\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To achieve complex structures like loops, decision making and simultaneous tasks we combine three fundamental structures: Linear sequences, convergence and divergence in OR (alternative threads), and convergence and divergence in Y (parallel threads). One usually starts describing a generic functional graph as a linear sequence and later adding bifurcation (OR and Y) as the complexity of the system increases.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/static/images/notes/CADESIMUSimulationTwo.png\",\n        alt: \"Example Program\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"/static/images/files/GRAFCETSimulation2.cad\",\n        children: \"Download the Example\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"A linear sequence is simplest structure, consisting of a succession of stages interconnected by transitions. Within a linear sequence only one stage should be active at a given time (simultaneous actions must be done as Y branches). A stage is activated when the previous one is active and the transition condition has been met. Activation of a stage implies the deactivation of the previous one.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/static/images/notes/ORBifurcationNetworksLab.png\",\n        alt: \"OR Bifurcation\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The OR bifurcation is a structure representing a divergence in OR followed by several possible paths or threads that in the end must converge back to the original macrostructure. This structure is intended as alternative processes that can be executed depending on a logical condition. They are analogous to the if, then, else structure, and therefore must be exclusive of each other when nested.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/static/images/notes/CADESIMUSimulationThree.png\",\n        alt: \"Example Program\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"/static/images/files/GRAFCETSimulation3.cad\",\n        children: \"Download the Example\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/static/images/notes/ANDBifurcationNetworksLab.png\",\n        alt: \"AND Bifurcation\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The AND bifurcation is a structure representing a divergence in AND followed by several threads that will start simultaneously when their common transition condition is met. Every thread must converge back into a single one as they continue their execution but this must be synchronized so that no thread is left behind. It must be avoided to converge AND in an OR convergence. Usually the last stages prior to an AND convergence are waiting for other stages to finish their job.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/static/images/notes/AdditionalStructuresANDORNetworksLab.png\",\n        alt: \"Bifurcation Relation\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Using AND and OR bifurcations we can create complex relations.\"\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h1, {\n      children: \"Sorting Line\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Virtual model of a sorting line. Composed from a storage tower with conveyor chain, a transport band or conveyor belt (both with unidirectional gear motors), three pistons (bidirectional motors) and four discharging tables. This control system has 17 digital inputs and 8 digital outputs. The virtual model can be emulated using a virtual machine within the LabVIEW environment and PLCSim.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/static/images/files/CADESIMUPistonsSimuPOne.cad\",\n          children: \"CADESIMU Pistons\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/static/images/files/CADESIMUSortingLine.7z\",\n          children: \"CADESIMU SortingLine\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/static/images/files/TIASortingLineNoColor.zip\",\n          children: \"Sorting Line Without Color\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/static/images/files/TIASortingLineColor.zip\",\n          children: \"Sorting Line With Color\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h1, {\n      children: \"PLC 1200\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/static/images/notes/DataTypesAndBitsNetworksLab.png\",\n        alt: \"Data Types\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Most PLC input and output addresses use individual bits but you can also reference a group of bits using bytes, words and double words. The range of possible values this groups can have depends on the data type they use (with sign or without sign). Note that only PLC 1500 and forwards can use 64 bit data types.\"\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            align: \"center\",\n            children: \"Data Type\"\n          }), _jsx(_components.th, {\n            align: \"center\",\n            children: \"Address\"\n          }), _jsx(_components.th, {\n            align: \"center\",\n            children: \"Bits\"\n          }), _jsx(_components.th, {\n            align: \"center\",\n            children: \"Range Sign\"\n          }), _jsx(_components.th, {\n            align: \"center\",\n            children: \"Range No Sign\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            align: \"center\",\n            children: \"Bit or Bool\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"M0.1\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"1\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"0 to 1\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"0 to 1\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            align: \"center\",\n            children: \"Byte\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"MB10\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"8\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"-128 to 127 (SINT)\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"0 to 255 (USINT)\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            align: \"center\",\n            children: \"Word\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"MW10\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"16\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"-32768 to 32767 (INT)\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"0 to 65535 (UINT)\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            align: \"center\",\n            children: \"DWord\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"MD10\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"32\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"-2147483648 to 2147483647 (DINT)\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"0 to 4294967295 (UDINT)\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            align: \"center\",\n            children: \"LWord\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"ML10\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"64\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"LINT\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"ULINT\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Set and Reset\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We have been setting (S) and resetting (R) bits to control the input and output of the PLC. This can be done more efficiently if we have stablished a state diagram using RS (activation) and SR (deactivation) flipflops.\"\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            align: \"center\",\n            children: \"R\"\n          }), _jsx(_components.th, {\n            align: \"center\",\n            children: \"S1\"\n          }), _jsx(_components.th, {\n            align: \"center\",\n            children: \"Q\"\n          }), _jsx(_components.th, {\n            align: \"center\",\n            children: \"S\"\n          }), _jsx(_components.th, {\n            align: \"center\",\n            children: \"R1\"\n          }), _jsx(_components.th, {\n            align: \"center\",\n            children: \"Q\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            align: \"center\",\n            children: \"0\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"0\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"Q\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"0\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"0\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"Q\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            align: \"center\",\n            children: \"0\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"1\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"0\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"0\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"1\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"0\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            align: \"center\",\n            children: \"1\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"O\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"1\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"1\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"0\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"1\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            align: \"center\",\n            children: \"1\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"1\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"0\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"1\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"1\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"1\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Timers\"\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"TP: Pulse timer when activated it generates a pulse with a set duration.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"TON: When activated the output will generate a signal after a set delay.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"TOF: When deactivated the output will generate a signal after a set delay.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"TONR: When activated the output will generate a signal after a set accumulated delay.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"RT: When activated it deletes the time data in the data block of another timer.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Counters\"\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"CTU: Ascending counter.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"CTD: Descending counter.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"CTUD: Ascending and Descending counter.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The CU or CD pulse input increments or decrements the counter by one, the R input resets the counter, the LOAD input sets a new PV input, the PV input is the value needed to activate the counter output, the QU output is true if CVmore than=PV, the QD output is true if CVless than=0 and the CV output is the current counter value. Note that PV and CV can input and output values different than boolean.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Comparators\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We can use comparators to compare two values as long as they have the same data type, generally if the comparison is true then the PLC contact will be activated. Valid comparisons include equal, different, greater, less, greater or equal and less or equal.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Scale and Standardize\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"SCALE_X\"\n      }), \" instruction scales the real normalized VALUE parameter (0.0 less than= VALUE less than= 1.0) to the data type and range of values specified in the MIN and MAX parameters, therefore OUT = VALUE(MAX-MIN)+MIN. The \", _jsx(_components.code, {\n        children: \"NORM_X\"\n      }), \" instruction normalizes the VALUE parameter (0.0 less than= OUT less than= 1.0), therefore OUT = (VALUE-MIN)/(MAX-MIN). Note that every parameter (MIN, MAX, OUT, VALUE) must be of the same data type.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{"title":"Industrial Networks Lab Notes","date":"2021-08-15","tags":["school","networks"]},"scope":{}},"metadata":{"title":"Industrial Networks Lab Notes","date":"2021-08-15","tags":["school","networks"],"slug":"school/industrialnetworksproyectone","fileName":"school/industrialnetworksproyectone.mdx"}},"__N_SSG":true},"page":"/posts/[...id]","query":{"id":["school","industrialnetworksproyectone"]},"buildId":"LQ_N8afeaVmFBDb_CzQcG","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>