---
title: Microcontrollers Notes
date: '2021-08-15'
tags: ['school', 'microcontrollers']
---

# Sistemas Numericos #

Un sistema numerico es un conjunto de reglas y simbolos utilizados para representar una cantidad, actualmente se utilizan sistemas numericos posicionales. Un guarismo o base es el conjunto de simbolos que utiliza un sistema numerico, por ejemplo binario (Base 2, digitos 0 y 1), decimal (Base 10, digitos del 0 al 9) o hexadecimal (Base 16 digitos del 0 al F). 

$$
\begin{gathered}
	\text{Sistema Numerico}\\
	A = a_n a_{n-1} \dots a_{2} a_{1} a_{1} . a_{-1} a_{-2} \dots a_{-m}\\
	\text{Sistema Decimal}\\
	D = d_{p-1} d_{p-2} \dots d_1 d_0\\
	D = \sum^{p-1}_{i=0} d_i 10^i \land d_i \in 0,1,\dots ,9\\
	1734_{10} = 1\times 10^3 + 7\times 10^2 + 3\times 10^1 + 4\times 10^0\\
	1734_{10} = 1\times 1000 + 7\times 100 + 3\times 10 + 4\times 1\\
	\text{Sistema Hexadecimal}\\
	H = h_{p-1} h_{p-2} \dots h_1 h_0\\
	H = \sum^{p-1}_{i=0} h_i 16^i \land h_i \in 0,1,\dots , E, F\\
	A3F5_{16} = 10\times 16^3 + 3\times 16^2 + 15\times 16^1 + 5\times 16^0\\
	A3F5_{16} = 10\times 4096 + 3\times 256 + 15\times 16 + 5\times 1\\
	A3F5_{16} = 40960 + 768 + 240 + 5 = 41973_{10}\\
	\text{Sistema Binario}\\
	B = b_{p-1} b_{p-2} \dots b_1 b_0\\
	B = \sum^{p-1}_{i=0} b_i 2^i \land b_i \in 0,1\\
	1101_{2} = 1\times 2^3 + 1\times 2^2 + 0\times 2^1 + 1\times 2^0\\
	1101_{2} = 8 + 4 + 0 + 1 = 13_{10}\\
\end{gathered}
$$

El sistema decimal se utiliza comunmente en la vida cotidiana y surge de la cantidad de dedos que tenemos en ambas manos. El sistema hexadecimal se utiliza para representar direcciones y contenidos en memoria. El sistema binario se utiliza dado su implementacion directa en las compuertas logicas de los circuitos digitales.

```python
def numToDec(numberStr, base):
	result = str(int(numberStr, base))
	if (base == 10): print(numberStr + 'd = ' + result)
	elif (base == 8): print(numberStr + 'o = ' + result)
	elif (base == 16): print(numberStr + 'h = ' + result)
	else: print(numberStr + ' = ' + result)

def numToBin(numberStr, base):
	result = str(bin(int(numberStr, base)))
	if (base == 10): print(numberStr + 'd = ' + result)
	elif (base == 8): print(numberStr + 'o = ' + result)
	elif (base == 16): print(numberStr + 'h = ' + result)
	else: print(numberStr + ' = ' + result)

def numToOct(numberStr, base):
	result = str(oct(int(numberStr, base)))
	if (base == 10): print(numberStr + 'd = ' + result)
	elif (base == 8): print(numberStr + 'o = ' + result)
	elif (base == 16): print(numberStr + 'h = ' + result)
	else: print(numberStr + ' = ' + result)
  
def numToHex(numberStr, base):
	result = str(hex(int(numberStr, base)))
	if (base == 10): print(numberStr + 'd = ' + result)
	elif (base == 8): print(numberStr + 'o = ' + result)
	elif (base == 16): print(numberStr + 'h = ' + result)
	else: print(numberStr + ' = ' + result)

numToBin('100', 10)
numToHex('100', 10)
numToBin('1024', 10)
numToHex('1024', 10)
numToBin('1023', 10)
numToBin('4B3A', 16)
numToDec('4B3A', 16)
```

# Memorias Microcontroladores #

La memoria es la habilidad de un objeto para almacenar información, las memorias digitales son circuitos capaces de almacenar información binaria. Una celda de memoria es el componentes fundamentales que nos permiten almacenar un bit, una palabra es un conjunto de bits cuyo tamaño depende del procesador (4 bits - 64 bits). Por ejemplo: 4004 Microprocessor (4 bits), 8051 Microcontroller (8 bits), 80286 - 80386 Microprocessor (16 bits), Pentium MP (32 bits), i3 - i5 - i7 Microprocessor (64 bits).

Un byte es una palabra de 8 bits, se utiliza como unidad de capacidad de memoria. La capacidad de memoria es la cantidad de bits que puede almacenar una memoria y se expresa como el producto entre el numero de localidades Base 2 (K, M, G, T, B) por el numero de bits en cada localidad. La capacidad también suele representarse en términos de bytes Base 10 (kB, MG, GB, TB, PB) o bytes Base 2 (KiB, MiB, GiB, TiB, PiB). Por ejemplo: Memoria de 1K x 8 tiene 1024 localidades de 8 bits cada una equivalente a un 1KiB de memoria. 

Las direcciones son identificadores únicos en hexadecimal para cada localidad en la memoria. Por ejemplo: Para una memoria de 1K x 8 se tienen 1024 localidades (0 - 1023) representadas por las direcciones en hexadecimal (000 - 3FF). 

```python
def memoryCapacity(numOfWords, suffix, numOfBits):
	if (suffix == 'K'): rangeWord = 2**10
	elif (suffix == 'M'): rangeWord = 2**20
	elif (suffix == 'G'): rangeWord = 2**30
	elif (suffix == 'T'): rangeWord = 2**40
	elif (suffix == 'P'): rangeWord = 2**50
	else: rangeWord = 1
	totalWords = numOfWords*rangeWord
	totalBits = totalWords*numOfBits
	print('Memory: ' + str(numOfWords) + suffix + ' x '  + str(numOfBits))
	print('Word Size: ' + str(numOfBits))
	print('Address Range: ' + str(totalWords) + ' = (0 - ' + str(totalWords-1) + ')')
	print('Address Range in Bin: ' + str(bin(totalWords)) + ' = (0 - ' + str(bin(totalWords-1)) + ')')
	print('Address Range in Hex: ' + str(hex(totalWords)) + ' = (0 - ' + str(hex(totalWords-1)) + ')')
	print('Total Bits: ' + str(totalBits))
	print()

memoryCapacity(1, 'K', 4)
memoryCapacity(64, 'K', 8)
memoryCapacity(2, 'M', 8)
memoryCapacity(2, 'K', 16)
```

El tiempo de accesso es el intervalo de tiempo desde la lectura de una dirección hasta la obtención de la información contenida en dicha dirección. Los buses de memoria son el conjunto de líneas que conectan al microprocesador con el circuito de memoria, el bus de direcciones los recibe la memoria para encontrar una localidad, el bus de datos es la la información que recibe o envía la unidad de memoria y el bus de control determina si la acción a realizar con la dirección y los datos actuales sera de lectura (RAM, ROM) o de escritura (RAM).

1. Read Only Memory (ROM): Memoria no volátil, es decir aquella que permanece intacta incluso cuando se interrumpe la fuente de poder en el circuito. Se utilizan para almacenar programas, programar funciones lógicas o generar tablas de datos.
	1. Mask ROM (MROM): Información no programable escrita en la creación del circuito integrado. Alto Volumen de producción.
	1. Programmable ROM (PROM): Información programable por el usuario en una unica ocasión (One Time Programmable). Volumen medio de producción. TMS27PC256 (32Kx8), TMS27PC64 (8Kx8).
	1. Erasable Programmable ROM (EPROM): Información reprogramable por medio de pulsos de alto voltaje a transistores MOSFET, se puede reprogramar mediante el reseteo por luz UV. 2716 (2Kx8), 2764 (8Kx8), 27256 (32Kx8) y 27512 (64Kx8).
	1. Electrical Erasable Programmable ROM (EEPROM): Información reprogramable eléctricamente, posibilita el programado de direcciones individuales (microcontroladores AVR). 2864 (8Kx8), 28256 (32Kx8) y 28512 (64Kx8).
	1. FLASH: Variante de la arquitectura EEPROM en donde se debe borrar por sectores (bloques de 16 bytes en adelante), generalmente contiene el programa del microcontrolador. Utilizado en SSD con tiempos de 35us - 100us y un costo por GB de $0.4. 2964 (8Kx8), 29256 (32Kx8) y 29512 (64Kx8).
	1. Magnetic Memory (HD, Floppy, Tape): Utiliza ranuras magneticas con tiempos de 5ms - 20ms y un costo por GB de $0.06.
2. Random Access Memory (RAM): Memoria volátil, es decir que la permanencia de la información depende de una fuente de poder. Se denomina *Random* debido a que el tiempo de acceso para cualquier localidad es el mismo.
	1. Static RAM (SRAM): Almacenamiento directo de variables, arreglos y estructuras, ocupa un area significativa de la superficie del microprocesador. Utilizado en Cache con celdas Flip-Flop, tiempos de 0.5ns - 2.5ns y un costo por GB de $5000. 64C16 (2Kx8) y 64C256 (32Kx8).
	1. Dynamic RAM (DRAM): Almacenamiento general de alta capacidad, bajo costo y velocidad moderada. Utiliza celdas capacitivas que requieren de una carga periódica (2ms a 10ms) debido a la corriente de fuga de las celdas. Con tiempos de 50ns - 70ns y un costo por GB de $6.

```python
def memoryChipBuses(A, D):
	K = 2**10
	TargetK = 2**A
	# Find Target Notation in K
	TargetInK = 0
	for i in range(1, 100):
		Target = i*K
		if Target == TargetK: 
			TargetInK = i
			break
	# Calculate last address
	LastAddress = TargetK-1
	TotalBits = TargetK*D
	print('nK x m: ' + str(TargetInK) + 'K x ' + str(D))
	print('Last Address Dec: ' + str(LastAddress))
	print('Last Address Hex: ' + str(hex(LastAddress)))
	print('Total Bits: ' + str(TotalBits))
	print()

memoryChipBuses(14, 8)
memoryChipBuses(13, 8)
memoryChipBuses(10, 4)
memoryChipBuses(12, 8)
memoryChipBuses(15, 8)
```

Las memorias tienen líneas de control que determinan su modo de operación, por lo general su activación es inversa: Chip Enable (CE) en HIGH implica el modo Standby del chip y una alta impedancia en las salidas, Write Enable (WE) en HIGH y Output Enable (OE) en LOW implica un modo de lectura en donde las salidas entregan información mientras que WE en LOW y OE en HIGH implica un modo de escritura en donde las salidas reciben información. En el caso de las memorias RAM es posible encontrar una configuración con WE y OE en HIGH la cual deshabilita por completo las salidas y un estado de Standby mediante Chip Select (CS) en HIGH (ambas con una alta impedancia en las salidas). Se utiliza alta impedancia para desactivar chips de memoria ya que permite conectar varios chips de memoria en serie seleccionando el chip activo mediante la impedancia de sus salidas.

 ```python
def logicMemoryFunctionOne(A, B, C):
	# Z = !A + ABC
	Z = not(A) or (A and B and C)
	return Z

# CASE 0
for i in range(0, 2**3):
	s1 = str(bin(i))
	s2 = str(hex(i))
	if i < 2: print(s1 + ' = ' + s2 + ' = ' + str(int(logicMemoryFunctionOne(0, 0, int(s1[2])))))
	elif i < 4: print(s1 + ' = ' + s2 + ' = ' + str(int(logicMemoryFunctionOne(0, int(s1[2]), int(s1[3])))))
	else: print(s1 + ' = ' + s2 + ' = ' + str(logicMemoryFunctionOne(int(s1[2]), int(s1[3]), int(s1[4]))))

print()
# CASE 1
for i in [0,4,2,6,1,5,3,7]:
	s1 = str(bin(i))
	s2 = str(hex(i))
	if i < 2: print(s1 + ' = ' + s2 + ' = ' + str(int(logicMemoryFunctionOne(0, 0, int(s1[2])))))
	elif i < 4: print(s1 + ' = ' + s2 + ' = ' + str(int(logicMemoryFunctionOne(0, int(s1[2]), int(s1[3])))))
	else: print(s1 + ' = ' + s2 + ' = ' + str(logicMemoryFunctionOne(int(s1[2]), int(s1[3]), int(s1[4]))))

print()
# CASE 2
outputCopy = hex(2**8-1)
for i in range(0, 2**3):
	s1 = str(bin(i))
	s2 = str(hex(i))
	if i < 2: 
		l = int(logicMemoryFunctionOne(0, 0, int(s1[2])))
		if l == 1: print(s1 + ' = ' + s2 + ' = ' + str(outputCopy))
		else: print(s1 + ' = ' + s2 + ' = 0')
	elif i < 4: 
		l = int(logicMemoryFunctionOne(0, int(s1[2]), int(s1[3])))
		if l == 1: print(s1 + ' = ' + s2 + ' = ' + str(outputCopy))
		else: print(s1 + ' = ' + s2 + ' = 0')
	else: 
		l = logicMemoryFunctionOne(int(s1[2]), int(s1[3]), int(s1[4]))
		if l == 1: print(s1 + ' = ' + s2 + ' = ' + str(outputCopy))
		else: print(s1 + ' = ' + s2 + ' = 0')

print()
# CASE 3
for i in range(2**13-2**3, 2**13):
	s1 = str(bin(i))
	s2 = str(hex(i))
	print(s1 + ' = ' + s2 + ' = ' + str(int(logicMemoryFunctionOne(int(s1[-3]), int(s1[-2]), int(s1[-1])))))
```

***

# Microcontroladores #

Gordon Moore, cofundador de Intel, predijo en 1965 que cada dos años se podrian integrar el doble de el numero de transistores en el mismo espacio, esta prediccion se conoce como la ley de moore. Esto a ocacionado que el tamaño de los transistores in circuitos integrados disminuya hasta el tamaño molecular, alrededor de los 5 nanometros. Por ejemplo el procesador Intel 4004 desarrollado en 1971 tenia una velocidad de 740 KHz, 2300 transistores, 4 Kb de memoria, 4 bits de acceso, 16 pines y transistores de 1 um de tamaño, hoy en dia un procesador Intel i9 13900K 5.8 GHz, 14,200,000,000 transistores, 64 GB de memoria, 64 bits de acceso, 2066 pins y transistores de 7 nm de tamaño. Otra comparacion que se realiza con las computadoras actuales es la de la computadora utilizada en la mision apollo para llevar al hombre a la luna en 1969 desarrollada en el MIT con una frecuencia de 2.048 MHz, de 16 bits, 2048 Bytes de RAM, 36864 de ROM, 32 Kg de peso y 55W de consumo de energia, con un costo estimado de 150,000 dolares. 

Conforme incremento la capacidad de procesamiento y frecuencia de operacion tambien aumento el consumo de energia dado que la potencia de de un circuito CMOS es proporcional a la carga capacitiva del semiconducor (practicamente constante), la frecuencia de operacion y al voltaje suministrado al cuadrado. Para contrarestar el consumo de energia conforme ha aumentado la frecuencia de operacion se ha disminuido el voltaje suministrado desde 5V hasta 1.25V en los procesadores actuales. El desempeño de los procesadores tambien se redujo debido la falta de inovacion en tecnologia de un nucleo, es por ello que hoy en dia los procesadores cuentan con varios nucleos que aprovechan el paralelismo al nivel de instrucciones a pesar de los probleas que genera su sincronizacion y distribucirga balanceado para cada nucleo. Los microcontroladores se utilizan en todas las industrias desde la aeronatuica (F-35 contiene 6 millones de lineas de codiogo),l la automotriz el 40% de su valor e produccion se encuentra en los sistemas electronicos

Microprocesadores

1. Circuito de proposito general para procesar informacion.
1. Instrucciones diseñadas para procesar datos, set de instrucciones extenso considerando valores florantes.
1. Alta capacidad de direccionamiento a memoria externa.
1. Acceso rapido a una memoria externa.
1. Memoria SRAM interna de gran tamaño.
1. Alta velocidad de procesamiento.
1. Encapsulados de gran volumen con integracion extrema de transistores.
1. Alto costo y bajo volumen de produccion.
1. Requiere de perifericos para funcionar (ROM, RAM, Timers, UART, Oscilador, Interruptor, Puertos)
1. Por ejemplo 8080 (8), 80186 (16), Pentium (32) o Xeon (64).

Microcontroladores
1. Circuito de proposito especifico para control externo.
1. Instrucciones diseñadas para aplicaciones de control, set de instrucciones reducido sin valores florantes.
1. Baja capacidad de direccionamiento a memoria externa.
1. Acceso lento a una memoria externa.
1. Memoria SRAM interna de bajo tamaño.
1. Baja velocidad de procesamiento.
1. Encapsulados de bajo volumen con integracion baja de transistores.
1. Bajo costo y alto volumen de produccion.
1. No requiere de ningun periferico para funcionar, es una minicomputadora en un solo chip.
1. Por ejemplo TMS1000 (4), 8048 (8), Mega8 (8), PIC16 (8), 80196 (16), 68HC300 (16), AVR32 (32), ARM32 (32).

La representacion numerica de 32 bits suele ser suficiente para la mayoria de las variables tradicionales. Sin embargo se ha optado por arquitecturas de 64 bits que ayuden a realizar operaciones con valores flotantes en el caso de los microprocesadores. El mercado por tamaño de procesamiento favorece a los microcontroladores de 32 bits sin embargo el mercado en unidades por tamaño de procesamiento sigue favoreciendo a los microcontroladores de 8 y 16 bits.

***

# AVR #

Atmel se funda en 1984 como productor de memorias no volatiles EEPROM y FLASH, en 1993 se posicionan en el mercado de microcontroladores con el chip AT89C51 para Intel que incluia memoria FLASH. En 1996 introducen al mercado los chips AVR (Tiny, Mega, Xmega) y AVR32. En 2003 la organizacion Arduino selecciona los chips AVR para su plataforma. En 2016 Atmel es comprada por Microchip para continuar la produccion de microcontroladores PIC y AVR.

La arquitectura AVR fue diseñada por 2 estudiantes en Noruega, Alf-Egil Bogen y Vegard Wollan y es la primera arquitectura con memoria FLASH dedicada en almacenar la memoria de codigo en lenguaje C. La variante tinyAVR tiene 0.5 a 16 kB de memoria FLASH, 6 a 32 pines y perifericos limitados, la variante megaAVR tiene 4 a 256 kB de memoria FLASH, 28 a 100 pines, multiplicador en hardware y perifericos adicionales (ADC, PWM) y la variante XmegaAVR tiene 16 a 384 kB de memoria FLASH, 44 a 100 pines y un procesador de seguridad criptografico.

El microcontrolador ATmega328P trabaja a 20MHz ejecutando cada instruccion en 50 nanosegundos, tiene un bajo consumo de energia incluso trabajando a 10 MHz unicamente consume alrededor de 5mA de corriente. Tiene 8 bits y 20 MIPS con un cristal de 20 MHz. En ensamblador cuenta con un set de 131 instrucciones la mayoria ejecutable en un ciclo del reloj, el chip cuenta con 28 pines, 32K x 8 registros de proposito general. En su memoria cuenta con 2 kB de SRAM (Datos volatiles del programa - Variables), 32 kB de memoria FLASH para 10,000 programaciones (Codigo Programa), ademas cuenta con 1024 bytes de EEPROM con 100,000 ciclos de escritura (Datos no volatiles del programa - Variables Permanentes). La arquitectura general es del circuito es Harvard Modificada.

Cuenta con dos temporizadores de 8 bits, un temporizador de 16 bits, 6 canales ADC de 10 bits, 6 salidas PWM, 23 lineas de entrada y salida programables, un comprador analogico integrado, un temporizador supervisor programable (Watchdog Timer) y instrucciones UART, SPI y I2C para la comunicacion serial con perifericos externos. Tiene 5 modos de consumo de energia con un rango de voltaje de 1.8 a 5.5 V. Puede utilizar un cristal externo hasta 20 MHz o utilizar el interno de 8 MHz. Puedes utilizar lenguaje ensamblador para programar el microcontrolador sin embargo se recomienza utilizar C junto con un compilador dado que es mas rapido el desarrollo, incorpora funciones y procedimientos utiles y es mucho mas facil de identificar problemas en el codigo.

En los circuitos electronicos digitales se colocan resistencias de pull-up o pull-down las cuales tienen la funcion de establecer si una entrada que no tiene inputs (flotada o desconectada) se debe considerar que tiene por defecto un 1 (pull-up) o un cero (pull-down). Usualmente los valores tipicos para este tipo de resistencias van desde 1K Ohms hasta 100 K Ohms. El microcontrolador ATMega328P tiene 23 lineas agrupadas en 3 puertos, en cada pin existen dos diodos de proteccion que limitan el voltaje (-0.7 a 0.7).

***

# Puertos #

El microcontrolador ATMega328 tiene 23 puertos agrupados en los puertos PB, PC y PD. En cada pin existen dos diodos de proteccion que limitan el voltaje de entrada (-0.7V - 0.7V). Si el puerto es configurado como salida los pines pueden dar o drenar 20mA a 5V sin embargo existe un limite en la corriente total de multiples puertos. Los tres registros que controlan el manejo de los puertos son:

* Data Direction Register (DDRx): Registro que configura la dirección de los pines del puerto, cada bit configura un pin fisico, un 0 (default) configura el pin como entrada y un 1 configura el pin como salida.
* PORT Data Register (PORTx): Si se configuro el pin como salida (DDRx=1) entonces en este registro se encontrara la informacion de dicha direccion, por el contrario si se configuro como entrada (DDRx=0) entonces se determina si el pin tendra un triple estado o una alta impedancia (PORTx=0) o si se conectara un pull-up a dicha entrada (PORTx=1).
* PORT Input Pin Address (PINx): Cuando se lee este registro se esta leyendo el estado de los pines fisicos, es decir que las entradas se deben accesar por medio de este registro (Lectura), a pesar de que este registro es unicamente para lectura sin embargo si se intenta escribir un 1 a este registro entonces se invertira (complementara) el valor en el registro PORTx. 

| DDxn | PORTxn | Mode I\O | Pull-Up | Note |
| :---: | :---: | :---: | :---: | :---: |
| 0 | 0 | Entrada | No | Alta Impedancia (HiZ) |
| 0 | 1 | Entrada | Si | Pull-Up en Entrada |
| 1 | 0 | Salida | No | Salida 0 |
| 1 | 1 | Salida | No | Salida 1 |

La configuracion de ambos registros se puede realizar en nivel byte (Hex) o a nivel bit (Bin).


 ```C
DDRA = 0x00; // Make al PORTA inputs (default)
PORTA = 0xFF; // Enable all with Pull Ups

// For DDRB = 1110 0001 and PORTB = 1101 1000
DDRB = 0xE1;
PORTB = 0xD8;
// Since default is 0 we can assign the ones bit by bit
DDRB.5=1; // PB5 salida 0
DDRB.0=1; // PB0 salida 0
DDRB.7=1; // PB7 salida 0
DDRB.6=1; // PB6 salida 0
PORTB.7=1; // PB7 cambia a salida 1
PORTB.6=1; // PB6 cambia a salida 1
PORTB.4=1; // PB4 Entrada con Pull Up
PORTB.3=1; // PB3 Entrada con Pull Up
// PB1 and PB2 stay as high Z inputs
data = PINB // To read input pins we read the PINB register.
```

***

# Problemas #

## Problema 1 ##

```C
// Blinking LED on PB0

#include <mega328p.h>
#include <io.h>
#include <delay.h>
void main(void)
{
	DDRB.0=1; // PB0 as output
    while (1)
        {
            PORTB.0=1; // PB0 turn LED ON
            delay_ms(500);
            PORTB.0=0; // PB0 turn LED OFF
            delay_ms(500);
        }
}
```

## Problema 2 ##

```C
// Read a 4 bit code from a dip switch. (PC0 - PC3)
// Use it with a 7 segment display to represent the bin value in hex (PD1 - PD7)
// Finally connect PD0 to a LED to display if it is a prime number

#include <mega328p.h>
#include <io.h>
#include <delay.h>
unsigned char value; // Byte to store value
unsigned char display[16] = {0xFC, 0x60, 0xDB, 0xF3, 0x66, 0xB7, 0xBE, 0xE1, 0xFE, 0xF6, 0xEE, 0x3F, 0x9C, 0x7B, 0x9E, 0x8E};
void main(void)
{
	DDRD=0xFF; // All PD as output
	DDRC=0x00; // All PC as input
	PORTC=0x0F; // Pull-Ups in PC0, PC1, PC2 and PC3	
    while (1)
        {
            value=PINC&0x0F; // Read PC but ignore (masking) PC4, PC5, PC6 and PC7
			PORTD=display[value];
        }
}
```

## Problema 3 ##

```C
// Read a dip switch. (PC0)
// Use it with a 7 segment display to stop and resume a timer of 0-9 seconds (PD1 - PD7)
// Finally connect PD0 to a LED to display if it is a prime number

#include <mega328p.h>
#include <io.h>
#include <delay.h>
unsigned char timerValue = 0;
unsigned char display[10] = {0xFC, 0x60, 0xDB, 0xF3, 0x66, 0xB7, 0xBE, 0xE1, 0xFE, 0xF6};
void main(void)
{
    DDRD=0xFF;
    DDRC=0x00;
    PORTC=0x0F;  
    while (1)
        {
            PORTD=display[timerValue];
            if (PINC.0 == 0)
            {
                timerValue++; // Add 1 to the Value if the Switch at PC0 is Pressed
            }
            if (timerValue == 10) 
            {
                timerValue = 0; // Restart the index to 0 if it reaches a value of 10
            }
            delay_ms(1000);            
        }
}
```

## Problema 4 ##

```C
// Create a comparitor of two 8 bit (byte) values
// It takes PB0-PB7 as the first byte and PD0-PD7 as the second byte
// Turn PC0 LED on if they are equal and/or PC1 LED on if X is greater than Y.

#include <mega328p.h>
#include <io.h>
unsigned char X,Y;
void main(void)
{
    DDRC.0 = 1;
    DDRC.1 = 1;
    while (1)
    {
        X = PINB;
        Y = PIND;
        if (X==Y)
        {   
            // Turn first LED indicator ON
            PORTC.0=1; 
            PORTC.1=0;
        }
        else 
        {
            // Turn first LED indicator OFF
            PORTC.0=0;
            if (X>Y)
            {   
                // Turn second LED indicator ON
                PORTC.1=1;
            }
            else 
            {
                // Turn second LED indicator OFF
                PORTC.1=0;
            }
        }
    }
}
```

## Problema 5 ##

```C
// Create an Arithmetic and Logical Unit or ALU
// It has 4 bit inputs A (PB0-PB3) and B (PB4-PB7), the result is outputed by PD0-PD4
// The operation can be selected from 8 possibilities using the bits PC0-PC3 as selector.
// A', A&B, A&'B, A|B, A|'B, Ax|B, Ax|'B, A+B (Math)

#include <mega328p.h>
#include <io.h>
unsigned char A,B,Op;
void main(void)
{
    DDRB = 0x00;
    DDRC = 0x00;
    DDRD = 0x1F;
    while (1)
    {
        A = PINB&0x0F;
        B = PINB&0xF0;
        B = B >> 4; // Carry the bits 4 places to the right
        Op = PINC&0x07;
        // 0011 = 3, 0101 = 5
        switch (Op) 
        {
            case 0: PORTD = ~A;     break;   //NOT 0011 = 1100 = 12 (Inverse)
            case 1: PORTD = A&B;    break;   //AND 0011 & 0101 = 0001 = 1 (Only if Both 1)
            case 2: PORTD = ~(A&B); break;   //NAND 0011 &' 0101 = 1110 = 14 (Only if Both 1 then Inv)
            case 3: PORTD = A|B;    break;   //OR 0011 | 0101 = 0111 = 7 (If any of both 1)
            case 4: PORTD = ~(A|B); break;   //NOR 0011 |' 0101 = 1000 = 8 (If any of both 1 then Inv)
            case 5: PORTD = A^B;    break;   //XOR 0011 x| 0101 = 0110 = 9 (Only if Equal)
            case 6: PORTD = ~(A^B); break;   //NXOR 0011 x|' 0101 = 1001 = (Only if Equal then Inv)
            case 7: PORTD = A+B;    break;   //SUM 0011 + 0101 = 1000 = 8 (Binary Sum)
            
        }
        unsigned char y = 0xC9;
        unsigned char x = 0x00;
        x = ~y; cout << hex << (int) x endl; 

    }
}
```

## Problema 6 ##

```C++
// Do some binary operations and print the result in C++
#include <iostream>
#include <string>
using namespace std;
int main()
{
    unsigned char y = 0xC9;
    unsigned char x = 0x00;
    x = ~y; cout << hex << (int) x << "\n";
    x = y<<3; cout << hex << (int) x << "\n";
    x = y>>4; cout << hex << (int) x << "\n";
    x = y&0x3F; cout << hex << (int) x << "\n";
    x = y^1; cout << hex << (int) x << "\n";
    x = y|0x10; cout << hex << (int) x << "\n";
	return 0;
}
```

TCCR0 = 0X06
TCNT0 is the number

## Problema 7 ##

```C
// Use the ADC on PC4 to control the speed of two sets of lights.
// Also implement a switch to use as a selector and change the sets.

#include <mega328p.h>
#include <io.h> 
#include <delay.h>  
#include <stdio.h>
#define ADC_VREF_TYPE ((0<<REFS1) | (1<<REFS0) | (0<<ADLAR)) // ADV Voltage Ref

unsigned int read_adc(unsigned char adc_input) {
    // Used to Read the Conversion Result
    ADMUX=adc_input | ADC_VREF_TYPE;
    delay_us(10); // ADC Input Voltage Stabilization Delay
    ADCSRA|=(1<<ADSC); // Start Conversion
    while ((ADCSRA & (1<<ADIF))==0); // Wait for Conversion to finish
    ADCSRA|=(1<<ADIF);
    return ADCW;
}

void delayKitt() { delay_ms(read_adc(4)); } 

unsigned char Seq1[14]={0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,0x02,0x04,0x08,0x10,0x20,0x40};
unsigned char Seq2[6]={0x81,0x42,0x24,0x18,0x24,0x42};
unsigned char i;
void main(void)
{
    ADMUX=ADC_VREF_TYPE; // ADC Voltage Reference: AVCC pin 
    // Digital input buffers on ADC0: On, ADC1: On, ADC2: On, ADC3: On, ADC4: Off, ADC5: On
    DIDR0=(0<<ADC5D) | (1<<ADC4D) | (0<<ADC3D) | (0<<ADC2D) | (0<<ADC1D) | (0<<ADC0D);
    // ADC Auto Trigger Source: ADC Stopped
    ADCSRA=(1<<ADEN) | (0<<ADSC) | (0<<ADATE) | (0<<ADIF) | (0<<ADIE) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
    ADCSRB=(0<<ADTS2) | (0<<ADTS1) | (0<<ADTS0);  

    CLKPR=0x80;
    CLKPR=0x04;
    DDRD=0xFF;
    DDRB=0x03;
    PORTC.0=1;
    while (1)
    {
        if (PINC.0==0)
        {
            for (i=0; i<14;i++)
            {
                PORTD=Seq1[i];
                PORTB=(PORTB&0xFC)|(Seq1[i]&0x03); 
                delayKitt();
                if (PINC.0==1) { break; }
            }
        }
        else 
        {
            for (i=0; i<6;i++)
            {
                PORTD=Seq2[i];
                PORTB=(PORTB&0xFC)|(Seq2[i]&0x03); 
                delayKitt();
                if (PINC.0==0) { break; }
            }
        }
    }
}

```

***

# LCD #

LCD es un Liquid Crystal Display con una luz de fondo basada en LEDS para mostrar caracteres alfanumericos. Existen una variedad de renglones y columnas disponibles, uno de los mas comunes es de 16x2 caracteres el cual cuenta con un controlador Hitachi HD44780 o un Hitachi KS0066 los cuales determinan que segmentos del display se encienden en base a las entradas incluyendo caracteres orientales dado que los controladores se fabrican en japon. En el caso del microcontrolador ATmega382P es conveniente dividir la linea de bits a la mitad y enviar el codigo en 2 cyclos para disminuir a la mitad la cantidad de lineas que se requieren.

| Pin | Symbol | Description | Pin | Symbol | Description |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 1 | Vss | General Ground| 9 | DB2 | Bit 2 |
| 2 | Vcc | General Supply 5V | 10 | DB3 | Bit 3 |
| 3 | Vo | Contrast Voltage | 11 | DB4 | Bit 4 |
| 4 | RS | Select Register | 12 | DB5 | Bit 5 |
| 5 | P/W | Read (H) or Write (L) Mode | 13 | DB6 | Bit 6 |
| 6 | E | Chip Enable | 14 | DB7 | Bit 7 |
| 7 | DB0 | Bit 0 | 15 | LED+ | +4.3 Backlight Anode |
| 8 | DB1 | Bit 1 | 16 | LED- | GND Backlight Cathode |


```C
// Display Library Use to create custom characters, for example a heart
// Use a LCD Custom Character Calculator to quicly create the hex values
#asm
    .equ __lcd_port=0x05 // PortB (0x05), PORTC (0x08), PORTD(0x0B)
    .equ __lcd_EN=1 // Specify how the pins are connected
    .equ __lcd_RS=0 
    .equ __lcd_D4=2
    .equ __lcd_D5=3
    .equ __lcd_D6=4
    .equ __lcd_D7=5
#endasm
#endasm
#include <display.h>
void main(void)
{
	SetupLCD(); // Start the library
	char heart[8] = {0x00,0x0A,0x15,0x11,0x0A,0x04,0x00,0x00}; // Create custom character
	CreateChar(0,heart); // Assign the custom character to the code 0
	MoveCursor(0,0); // Move the cursor to one of the 32  spaces (0-15, 0-1)
	CharLCD(0); // Display the custom character
	MoveCursor(2,0);
	CharLCD('H'); // Display default character
	StringLCD("HOLA"); // Display a string
	StringLCD2("MUNDO",200) // Delay after each char
	char customString[] = "!!!";
	StringLCDVar(customString);
	EraseLCD(); // Erase LCD and move cursor to 0,0
	UnderscoreCursor(); // Change from invisible (default) to underscore
	NoUnderscroreCursor(); //Removes the underscore
	BlinkCursor(); // Change to a blinking cursor
	NoBlinkCursor(); // Removes the blinking cursor

}
```

## Problema 1 ##

```C
// Create a program that animates 2 messages using a custom character.
// The messages have a 2 second delay and at the end you must use another 2 custom characters.

#asm
    .equ __lcd_port=0x05
    .equ __lcd_EN=1
    .equ __lcd_RS=0
    .equ __lcd_D4=2
    .equ __lcd_D5=3
    .equ __lcd_D6=4
    .equ __lcd_D7=5
#endasm
#include <mega328p.h>
#include <io.h>
#include <delay.h>
#include <display.h>                  
char car0[8]={0x0A,0x0A,0x0A,0x00,0x11,0x0E,0x00,0x00};
char car1[8]={0x00,0x15,0x0E,0x1F,0x0E,0x15,0x00,0x00};    
char car2[8]={0x02,0x04,0x0E,0x01,0x0F,0x11,0x0F,0x00};  
void main()
{
    SetupLCD(); 
    CreateChar(0,car0);  
    CreateChar(1,car1);
    CreateChar(2,car2);
    while(1)
    {
        MoveCursor(0,0);
        StringLCD("Clase de Micros");  
        MoveCursor(1,1);
        StringLCD("Invierno 2023");
        delay_ms(2000);
        EraseLCD();
        MoveCursor(2,0);
        StringLCD("Iniciar");
        CharLCD(2);
        StringLCD(" la");  
        MoveCursor(0,1);
        StringLCD("parte pr");
        CharLCD(2);
        StringLCD("ctica");
        CharLCD(0);
        CharLCD(1);
        delay_ms(2000);
        EraseLCD();
    }              
}

```

## Problema 2 ##

```C
// Create a timer of seconds with a long variable and sprintf

#asm
    .equ __lcd_port=0x05
    .equ __lcd_EN=1
    .equ __lcd_RS=0
    .equ __lcd_D4=2
    .equ __lcd_D5=3
    .equ __lcd_D6=4
    .equ __lcd_D7=5
#endasm
#include <mega328p.h>
#include <delay.h>
#include <display.h>   
#include <stdio.h>
// To update this variable we can transform the numers into a string (sprintf)
// Or we can assign a variable for each position of the number (x, xx, xxx etc)
unsigned long seg=0;
char Cadena [17];
void main(void)
{
    SetupLCD();
    StringLCD("Tiempo en Seg");
    while (1)
    {
        // The spaces are used to delete unwanted chars after overflow (255)
        // This will restart the timer without the need of erasing the LCD
        sprintf(Cadena, "%lu              ", seg); 
        MoveCursor(0,1);
        StringLCDVar(Cadena);
        seg++;
        delay_ms(1000);
    }
}

```

## Problema 3 ##

```C
// Create a timer MM:SS.D that uses a switch to pause and resume. It will also have a push button to reset.
// Also make an animation if the timer is running.

#asm
    .equ __lcd_port=0x05
    .equ __lcd_EN=1
    .equ __lcd_RS=0
    .equ __lcd_D4=2
    .equ __lcd_D5=3
    .equ __lcd_D6=4
    .equ __lcd_D7=5
#endasm
#include <mega328p.h>
#include <delay.h>
#include <display.h>   
#include <stdio.h>
unsigned char M=0, S=0, D=0, G=0;
char car0[8]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
char car1[8]={0x0E,0x0E,0x04,0x1F,0x04,0x04,0x0A,0x0A};
char car2[8]={0x06,0x06,0x14,0x0E,0x05,0x04,0x0A,0x12};
char car3[8]={0x0C,0x0C,0x05,0x0E,0x14,0x04,0x0A,0x09};
char Cadena[17];
void main(void)
{
    SetupLCD(); 
    CreateChar(0,car0); // Blank  
    CreateChar(1,car1); // Stationary
    CreateChar(2,car2); // Running to Right
    CreateChar(3,car3); // Running to Left
    PORTD.0=1;
    PORTD.1=1;
    while (1)
    {
        sprintf(Cadena,"%02i:%02i:%i",M,S,D);
        MoveCursor(4,0);
        StringLCDVar(Cadena);
        delay_ms(62);  //0.1 Seconds Adjustment 
        delay_us(350);
        // When pressing the switch stop the increment
        if (PIND.0==0) 
        {
            switch (G) 
            {
                case 0: MoveCursor(7,1); CharLCD(0); MoveCursor(8,1); CharLCD(1); break;
                case 1: MoveCursor(8,1); CharLCD(0); MoveCursor(9,1); CharLCD(2); break;
                case 2: MoveCursor(9,1); CharLCD(0); MoveCursor(10,1); CharLCD(2); break;
                case 3: MoveCursor(10,1); CharLCD(0); MoveCursor(11,1); CharLCD(2); break;
                case 4: MoveCursor(11,1); CharLCD(0); MoveCursor(12,1); CharLCD(2); break;
                case 5: MoveCursor(12,1); CharLCD(0); MoveCursor(13,1); CharLCD(2); break;
                case 6: MoveCursor(13,1); CharLCD(0); MoveCursor(14,1); CharLCD(2); break;
                case 7: MoveCursor(14,1); CharLCD(0); MoveCursor(15,1); CharLCD(1); break;
                case 8: MoveCursor(15,1); CharLCD(0); MoveCursor(14,1); CharLCD(3); break;
                case 9: MoveCursor(14,1); CharLCD(0); MoveCursor(13,1); CharLCD(3); break;
                case 10: MoveCursor(13,1); CharLCD(0); MoveCursor(12,1); CharLCD(3); break;
                case 11: MoveCursor(12,1); CharLCD(0); MoveCursor(11,1); CharLCD(3); break;
                case 12: MoveCursor(11,1); CharLCD(0); MoveCursor(10,1); CharLCD(3); break;
                case 13: MoveCursor(10,1); CharLCD(0); MoveCursor(9,1); CharLCD(3); break;
                case 14: MoveCursor(9,1); CharLCD(0); MoveCursor(8,1); CharLCD(3); break;
                case 15: MoveCursor(8,1); CharLCD(0); MoveCursor(7,1); CharLCD(3); break;
                case 16: MoveCursor(7,1); CharLCD(0); MoveCursor(6,1); CharLCD(3); break;
                case 17: MoveCursor(6,1); CharLCD(0); MoveCursor(5,1); CharLCD(3); break;
                case 18: MoveCursor(5,1); CharLCD(0); MoveCursor(4,1); CharLCD(3); break;
                case 19: MoveCursor(4,1); CharLCD(0); MoveCursor(3,1); CharLCD(3); break;
                case 20: MoveCursor(3,1); CharLCD(0); MoveCursor(2,1); CharLCD(3); break;
                case 21: MoveCursor(2,1); CharLCD(0); MoveCursor(1,1); CharLCD(3); break;
                case 22: MoveCursor(1,1); CharLCD(0); MoveCursor(0,1); CharLCD(1); break;
                case 23: MoveCursor(0,1); CharLCD(0); MoveCursor(1,1); CharLCD(2); break;
                case 24: MoveCursor(1,1); CharLCD(0); MoveCursor(2,1); CharLCD(2); break;
                case 25: MoveCursor(2,1); CharLCD(0); MoveCursor(3,1); CharLCD(2); break;
                case 26: MoveCursor(3,1); CharLCD(0); MoveCursor(4,1); CharLCD(2); break;
                case 27: MoveCursor(4,1); CharLCD(0); MoveCursor(5,1); CharLCD(2); break;
                case 28: MoveCursor(5,1); CharLCD(0); MoveCursor(6,1); CharLCD(2); break;
                case 29: MoveCursor(6,1); CharLCD(0); MoveCursor(7,1); CharLCD(2); break;
            }
            D++;
            G++; 
        }
        if (G==30)
        {
            G=0;
        }
        // If increment is active then continue adding
        if (D==10) 
        {
            D=0;
            S++;
            if(S==60)
            {
                S=0;
                M++;
                if(M==60)
                {
                    M=0;
                }
            }
        }       
        // When pressing push restart timer
        if (PIND.1 ==0) 
        {
            M=0;
            S=0;
            D=0;
            G=0;
            EraseLCD();
        }
    }
}

```


## Problema 4 ##

```C
// Create a PacMan Message where Pacman eats the message.

#asm
   .equ __lcd_port=0x0B
   .equ __lcd_EN=3
   .equ __lcd_RS=2
   .equ __lcd_D4=4
   .equ __lcd_D5=5
   .equ __lcd_D6=6
   .equ __lcd_D7=7
#endasm           

#include <mega328p.h>
#include <delay.h>
#include <display.h> 
#include <stdio.h>
#define ADC_VREF_TYPE ((0<<REFS1) | (1<<REFS0) | (0<<ADLAR)) // ADV Voltage Ref

unsigned int read_adc(unsigned char adc_input) {
    // Used to Read the Conversion Result
    ADMUX=adc_input | ADC_VREF_TYPE;
    delay_us(10); // ADC Input Voltage Stabilization Delay
    ADCSRA|=(1<<ADSC); // Start Conversion
    while ((ADCSRA & (1<<ADIF))==0); // Wait for Conversion to finish
    ADCSRA|=(1<<ADIF);
    return ADCW;
}

void delayPacMan() {
    delay_ms(read_adc(0)/4);
} 

void message() 
{
   MoveCursor(5,0);
   StringLCD("Hello");
   MoveCursor(3,1);
   StringLCD("Mr. PacMan");
}

unsigned char PacMan1[8]={0x0E,0x1D,0x1E,0x1C,0x1E,0x1F,0x0E,0x00}; // Open Right
unsigned char PacMan2[8]={0x0E,0x1D,0x1F,0x1E,0x1F,0x1F,0x0E,0x00}; // Closed Right
unsigned char PacMan3[8]={0x0E,0x17,0x1F,0x0F,0x1F,0x1F,0x0E,0x00}; // Open Left
unsigned char PacMan4[8]={0x0E,0x17,0x1F,0x1F,0x1F,0x1F,0x0E,0x00}; // Closed Left
signed char i = 0;
signed char G = 0;
signed char T = 0;
void main(void)
{
    CLKPR=0x80;
    CLKPR=0x04;
    
    ADMUX=ADC_VREF_TYPE; // ADC Voltage Reference: AVCC pin 
    // Digital input buffers on ADC0: On, ADC1: On, ADC2: On, ADC3: On, ADC4: Off, ADC5: On
    DIDR0=(0<<ADC5D) | (0<<ADC4D) | (0<<ADC3D) | (0<<ADC2D) | (0<<ADC1D) | (1<<ADC0D);
    // ADC Auto Trigger Source: ADC Stopped
    ADCSRA=(1<<ADEN) | (0<<ADSC) | (0<<ADATE) | (0<<ADIF) | (0<<ADIE) | (0<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
    ADCSRB=(0<<ADTS2) | (0<<ADTS1) | (0<<ADTS0);  

    SetupLCD();

    CreateChar(0,PacMan1);
    CreateChar(1,PacMan2); 
    CreateChar(2,PacMan3);
    CreateChar(3,PacMan4); 
    
    PORTC.1=1;

    while (1)
    {
        message();
        if (PINC.1==0&T==0) {T=1;}
        if (PINC.1==1&T==0) {T=3; G=15;}
        if (T==1){
            for (i=G;i<16;i++)
            {
                G++;
                if (PINC.1==1) {T=3; G--; G--; break;} // If right up (1) toggle go to (3)
                MoveCursor(i,0);
                CharLCD(0);
                delayPacMan();
                MoveCursor(i,0);
                CharLCD(1);
                delayPacMan();           
                MoveCursor(i,0);
                CharLCD(' ');
            }
            if (T==1) {T=2;} // If right up (1) end same go to (2)
        }
        if (T==2){
            for (i=G;i>=0;i--)               
            {
                G--;
                if (PINC.1==1) {T=4; G++; G++; break;} // If left down (2) toggle go to right down (4)
                MoveCursor(i,1);
                CharLCD(2); 
                delayPacMan();
                MoveCursor(i,1);
                CharLCD(3);
                delayPacMan();           
                MoveCursor(i,1);
                CharLCD(' '); 
         
            }
            if (T==2) {T=0;} // If left down (2) end then go to end 
        }
        if (T==3){
            for (i=G;i>=0;i--)               
            {
                G--; 
                if (PINC.1==0) {T=1; G++; G++; break;} // If left up (3) toggle go to (1)
                MoveCursor(i,0);
                CharLCD(2);
                delayPacMan();
                MoveCursor(i,0);
                CharLCD(3);
                delayPacMan();           
                MoveCursor(i,0);
                CharLCD(' ');
            }
            if (T==3) {T=4;} // If left up (3) end same go to (4)
        }
        if (T==4){
            for (i=G;i<16;i++)
            {
                G++;
                if (PINC.1==0) {T=2; G--; G--; break;} // If right down (4) toggle go to left down (2)
                MoveCursor(i,1);
                CharLCD(0);
                delayPacMan();
                MoveCursor(i,1);
                CharLCD(1);
                delayPacMan();           
                MoveCursor(i,1);
                CharLCD(' ');              
            }
            if (T==4) {T=0;} // // If right down (4) end then go to end 
        }
    }
}

```

***

# Timers #

El ATMega328P cuenta con temporizadores-contadores en modo normal. Los contadores digitales integrados en el microcontrolador se pueden aproximar utilizando circuitos flip flop por cada bit adicional. En el modo normal los timers cuentan desde 0 hasta su cuenta maxima, si sobrepasan esa cuenta se reinicia el timer y se activa la bandera de overflow (TOVn). En el modo CTC (Clear Timer on Compare Match) el timer cuenta desde 0 hasta un registro con el que compara su cuenta, si sobrepasa al registro se reinicia a 0 automaticamente. En el modo PWM se genera una modulacion por ancho de pulsos en cualquier salida OCNX en donde N es 0, 1, 2, 3 y X es A, B o C.

1. Timer 0: Timer de 8 bits con pre-escalamiento independiente con un maximo de 256 cuentas y capacidad para contar eventos o intervalos de tiempo por medio de T0 (PD4). Tambien permite la generación de hasta 2 señales PWM.
1. Timer 1: Timer de 16 bits con pre-escalamiento independiente con un maximo de 65536 cuentas y capacidad para contar eventos o intervalos de tiempo por medio de T1 (PD5). Tiene un modo de captura de entrada ademas del modo de comparacion por hardware que tiene T0 y T2. Permite la generacion de hasta 2 señales PWM.
1. Timer 2: Timer de 8 bits con pre-escalamiento independiente con un maximo de 256 cuentas para intervalos de tiempo por medio de T2 (PD6). Tambien permite la generación de hasta 2 señales PWM. A diferencia del Timer 0 o 1 tiene la capacidad para contar utilizando un cristal externo de 32 KHz independiente al oscilador integrado.

El pre-escalador tiene 3 bits de seleccion (CSX0, CSX1, CSX3) en multiplexores por cada timer para seleccionar el reloj que queremos utilizar con cada intervalo de tiempo del timer. En el caso del Timer 2 se agregaron pre-escaladores extras debido a su incapacidad para contar eventos. Para el registro de control de timer TIFR0 y TIFR1 su primer bit TOV0 y TOV1 son las banderas de overflow las cuales se colocan en 0 por medio de una interrupcion de hardware o al sobreescribir un 1. El registro pre-escalador para el timer 0 es TCCR0B en donde se selecciona el reloj a utilizar por el timer con los 3 bits mas significativos (CS00, CS001 y CS02).

| CS02 | CS01 | CS00 | Description |
| :---: | :---: | :---: | :---: |
| 0 | 0 | 0 | No Clock Source (Timer/Counter Stopped) |
| 0 | 0 | 1 | CLK 1 |
| 0 | 1 | 0 | CLK 8 |
| 0 | 1 | 1 | CLK 64 |
| 1 | 0 | 0 | CLK 256 |
| 1 | 0 | 1 | CLK 1024 |
| 1 | 1 | 0 | External Clock Source on T0 (Falling Edge) |
| 1 | 1 | 1 | External Clock Source on T0 (Rising Edge) |

Para el timer 1 funciona de forma similar mediante el registro TCCR1B con bits de Clock Select (CS12, CS11 y CS10).

| CS12 | CS11 | CS10 | Description |
| :---: | :---: | :---: | :---: |
| 0 | 0 | 0 | No Clock Source (Timer/Counter Stopped) |
| 0 | 0 | 1 | CLK 1 |
| 0 | 1 | 0 | CLK 8 |
| 0 | 1 | 1 | CLK 64 |
| 1 | 0 | 0 | CLK 256 |
| 1 | 0 | 1 | CLK 1024 |
| 1 | 1 | 0 | External Clock Source on T1 (Falling Edge) |
| 1 | 1 | 1 | External Clock Source on T1 (Rising Edge) |

El timer almacena su cuenta interna en TCNT0 de 8 bits o en TCNT1H y TCNT1L para el timer 1 de 16 bits. Para asegurarnos que ambos bytes se puedan escribir y leer de forma simultanea se realiza el acceso por medio de un registro temporal de 8 bits TEMP, en cualquier otro caso es necesario seguir un orden especifico de escritura y leectura. Para la escritura se escribe en TCNT1H primero (por medio de TEMP) y luego se escribe en TCNT1L, por ejemplo para escribir 0x5001 (16 bits) en TCNT1 se escribe primero 0x50 en TCNT1H y luego 0x01 en TCNT1L (Estre procediminto es igual para los registros OCR1H y OCR1L de 16 bits). Para la lectura se lee primero TCNT1L y luego TCNT1H, por ejemplo para leer 0x3345 de TCNT1 se asigna primero TCNT1L a una variable con 0x45 y despues TCNT1H a una variable con 0x33.

## Problema 1 ##

```C
// Create a 100Hz 50% Square Signal. (5ms delay).

#include <mega328p.h>

void delay5msTimer0()
{
    TCCR0B=0x03; // Prescaler to 64 
    TCNT0 = 0xB2; // Add Value for Delay
    while (TIFR0.TOV0==0); // Wait for overflow
    TIFR0.TOV0=1; // Restart Overflow Flag
    TCCR0B=0; // Turn Timer off
}

void delay5msTimer1 ()
{
    TCCR1B=0x01; // Prescaler to 1
    // ADJUST FOR EXECUTION TIME 60536 + 24 = 60560
    TCNT1H = 60560 /256; // Add Value for Delay
    TCNT1L=60560%256; // Add Value for Delay
    while (TIFR1.TOV1==0); // Wait for overflow
    TIFR1.TOV1=1; // Restart Overflow Flag
    TCCR1B=0; // Turn Timer off
}


void main(void)
{
    DDRB.0=1; // Output pin for square wave
    while (1)
    {
        // Calculate the number in microseconds and adjust
        // 10.048 ms is 24 counts per each delay5ms to reach 10.000 ms
        PORTB.0=1;
        delay5msTimer1();
        PORTB.0=0;
        delay5msTimer1();
    }
}
```

## Problema 2 ##

```C
// Create a program to generate random numbers, use a seed with a timer and a push
// The timer will run permanently generating seeds, the number must be from 0 to 999
// Each time you generate a number turn the buzzer at 400 Hz for 0.2 seconds.

#asm
    .equ __lcd_port=0x0B
    .equ __lcd_EN=3
    .equ __lcd_RS=2
    .equ __lcd_D4=4
    .equ __lcd_D5=5
    .equ __lcd_D6=6
    .equ __lcd_D7=7
#endasm
#include <mega328p.h>
#include <delay.h>
#include <display.h>   
#include <stdio.h>
#include <stdlib.h>

unsigned char num;                            
char Cadena[17];
unsigned char i;
void main(void)
{
    CLKPR=0x80;
    CLKPR=0x04;
    SetupLCD();
    StringLCD(" Random Numbers"); 
    PORTC.0=1;  // Pull Up for Push in PB0
    DDRC.1=1;  // Output for Buzzer
    TCCR0B=0x01; // Start timer in CK (1)

    while (1)
    {     
         
        if (PINC.0==0)
        {     
            srand(TCNT0);                                   
            num=rand()%1000;
            sprintf(Cadena,"%003i",num);
            MoveCursor(6,1);
            StringLCDVar(Cadena);
            //Sound at 0.2 seg at 400 Hz
            for (i=0; i<80; i++) 
            {
                PORTC.1=1;
                delay_us(1250);
                PORTC.1=0;
                delay_us(1250);
            }
            //while(PINB.0==0);
            while(PINC.0==0);
        }

    }
}
```

***

# CTC Mode #

En el modo CTC (Clear Time on Compare Match) se utiliza un registro para determinar cuando termina el conteo de los timers. El timer  (TCNT0) se compara si su valor es equivalente a (OCR0A) haciendo un clear automática. Es decir que en este caso no es necesario calcular el numero de cuentas como la diferencia entre el maximo y el numero deseado, simplemente basta con colocar el numero de cuentas en el registro de comparacion. Ademas de ser mas practico que el modo normal esto nos permite generar señales de pulsos cuadrados de frecuencia variable utiles en aplicaciones de sonido e implementar retardos periodicos lo cual es util en un proceso de muestreo para señales de control con interrupciones. 

Para el T0 y el T2 existen registros de comparacion de 8 bits OCR0A y OCR2A mientras que el T1 tiene registros de comparacion de 16 bits OCR1A divido en OCR1AH y OCR1L. Las salidas cambian de estado en CTC cuando se reinician los timers son PD6 para el Timer 0 (OC0A), PB1 para el Timer 1 (OC1A) y PB3 para el Timer 2 (OC2A). Si se utilizan estas salidas se puede modificar el generador de ondas mediante los registros de control WGMXX, si utilizamos el Timer 0 entonces 2 se encuentran en TCCR0A y 1 en TCCR0B, si utilizamos el Timer 1 entonces 2 se encuentran en TCCR1A y 2 en TCCR1B. 

$$
\begin{gathered}
	\text{CTC Frequency}\\
	f = \frac{CK}{2(N)(OCRnA + 1)}\\
	CK = \text{ Micro Clock Freq}\\
	N = \text{ Selected Pre-scaler}\\
\end{gathered}
$$

| WGM02 | WGM01 | WGM00 | Mode | TOP | Update of OCRX | TOV Flag Set |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 0 | 0 | 0 | Normal | 0xFF | Immediate | 0xFF |
| 0 | 0 | 1 | PWM (Phase Correct) | 0xFF | TOP | 0x00 |
| 0 | 1 | 0 | CTC | OCRA | Immediate | 0xFF |
| 0 | 1 | 1 | PWM (Fast) | 0xFF | 0x00 | 0xFF |
| 1 | 0 | 0 | Reserved | 0 | 0 | 0 |
| 1 | 0 | 1 | PWM (Phase Correct) | OCRA | TOP | 0x00 |
| 1 | 1 | 0 | Reserved | 0 | 0 | 0 |
| 1 | 1 | 1 | PWM (Fast) | OCRA | 0x00 | TOP |

Finalmente es importante configurar el registro de comparacion para CTC (Sin PWM) es el A (COM0A1 y COM0A0) los cuales se encuentran en TCCR0A, mientras que el registro de comparacion B se utiliza con PWM.

| COM0A1 | COM0A0 | Description | 
| :---: | :---: | :---: | 
| 0 | 0 | Normal Port (OC0A Disconnected) | 
| 0 | 1 | OC0A Toggle on Compare | 
| 1 | 0 | OC0A Clear on Compare | 
| 1 | 1 | OC0A Set on Compare |

| WGM13 | WGM12 | WGM11 | WGM10 | Mode | TOP | Update of OCRX | TOV Flag Set |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 0 | 0 | 0 | 0 | Normal | 0xFFFF | Immediate | 0xFFFF |
| 0 | 0 | 0 | 1 | PWM (Phase Correct) 8 bit | 0x00FF | TOP | 0x0000 |
| 0 | 0 | 1 | 0 | PWM (Phase Correct) 9 bit | 0x01FF | TOP | 0x0000 |
| 0 | 0 | 1 | 1 | PWM (Phase Correct) 10 bit | 0x03FF | TOP | 0x0000 |
| 0 | 1 | 0 | 0 | CTC | OCR1A | Immediate | 0xFFFF |
| 0 | 1 | 0 | 1 | PWM (Fast) 8 bit | 0x00FF | 0x0000 | TOP |
| 0 | 1 | 1 | 0 | PWM (Fast) 9 bit | 0x01FF | 0x0000 | TOP |
| 0 | 1 | 1 | 1 | PWM (Fast) 10 bit | 0x03FF | 0x0000 | TOP |
| 1 | 0 | 0 | 0 | PWM (Phase and Freq Correct) | ICR1 | 0x0000 | 0x0000 |
| 1 | 0 | 0 | 1 | PWM (Phase and Freq Correct) | OCR1A | 0x0000 | 0x0000 |
| 1 | 0 | 1 | 0 | PWM (Phase Correct) | ICR1 | TOP | 0x0000 |
| 1 | 0 | 1 | 1 | PWM (Phase Correct) | OCR1A | TOP | 0x0000 |
| 1 | 1 | 0 | 0 | CTC | ICR1 | Immediate | 0xFFFF |
| 1 | 1 | 0 | 1 | Reserved | 0 | 0 | 0 |
| 1 | 1 | 1 | 0 | PWM (Fast) | ICR1 | 0x0000 | TOP |
| 1 | 1 | 1 | 1 | PWM (Fast) | OCR1A | 0x0000 | TOP |

## Problema 1 ##

 ```C
// Generate 2 square waves using Timer 0 and Timer 1 in CTC mode (Use default Outputs)
// The first wave is 400Hz and the second one is 1250 Hz, also use a push to activate the first one

#include <mega328p.h>

void main(void)
{
    // Timer 0
    DDRD.6=1; // Output PD6 for Timer 0
    TCCR0A = 0x42;
    TCCR0B = 0X02; 
    OCR0A = 155;
    PORTD.0 = 1; // Input for Push
    
    // Timer 1
    DDRB.1=1; // Output PB1 for Timer 1
    TCCR1A = 0x40;
    TCCR1B = 0x09;
    OCR1AH = 399/256;
    OCR1AL = 399%256;
    
    while (1)
    {
        if (PIND.0==0) TCCR0B = 0X02; // If push is pressed use (8 preescaler)
        else TCCR0B = 0X00; // If not then don't use a preescaler (Timer Stops)        
    }
}
```

***

# PWM #

La modulacion por ancho de pulso permite generar ondas cuyo ciclo de carga (DC) sea distinto al cincuenta porciento. 

$$
\begin{gathered}
	\text{PWM DC Calculation}\\
	T = T_0 + T_1\\
	f = 1/T\\
	DC = \frac{T_1}{T} = \frac{T_1}{T_0 + T_1}\\
\end{gathered}
$$

Compare Output Mode for Fast PWM

| COM0A1 | COM0A0 | Description | 
| :---: | :---: | :---: | 
| 0 | 0 | Normal Port (OC0A Disconnected) | 
| 0 | 1 | WGM02 = 1 (Toggle OC0A on Compare Match) else (Disconnected)| 
| 1 | 0 | OC0A Clear on Compare, set OC0A at BOTTOM (non inverting) | 
| 1 | 1 | OC0A Set on Compare, clear OC0A at Bottom (inverting) |

Compare Output Mode for Phase Correct PWM

| COM0A1 | COM0A0 | Description | 
| :---: | :---: | :---: | 
| 0 | 0 | Normal Port (OC0A Disconnected) | 
| 0 | 1 | WGM02 = 1 (Toggle OC0A on Compare Match) else (Disconnected)| 
| 1 | 0 | OC0A Clear when up-counting, set OC0A when down-counting (Compare) | 
| 1 | 1 | OC0A Clear when down-counting, set OC0A when up-counting (Compare |

Ambos modos de PWM, fast y phase correct, utilizan un parametro TOP el cual determina la maxima cuenta del timer la cual puede ser configurada para adoptar los siguientes valores:

1. Timer 0: FFh (8 bit PWM) y OCR0A.
2. Timer 1: FFh (16 bit PWM), 1FFh (9 bit PWM), 3FFh (10 bit PWM), ICR1, OCR1A.
1. Timer 2: FFh (8 bit PWM), OCR2A.

Existen 6 señales independientes de PWM dadas por el Timer 0 (OC0A, OC0B), Timer 1 (OC1A, OC1B) y Timer 2 (OC2A, OC2B). En el modo Fast PWM la señal PWM en OCnA sera 1 logico si OCRnA es mayor que el contador del timer TCNTn, de lo contrario tendra un valor de 0 logico, de modo complementario OCnB sera 1 logico si OCRnB es mayor que el contador del timer TCNTn y de lo contrario sera 0. El modo Phase Correct es igual que el Fast PWM con la diferencia de que el contador en vez de reiniciarse cuando llega a TOP simplemente realiza una cuenta inversa decreciendo su valor hasta llegar a 0.

$$
\begin{gathered}
	\text{Fast PWM Frequency}\\
	f_{OCnx} = \frac{CK}{(N)(TOP + 1)}\\
	CK = \text{ Micro Clock Freq}\\
	N = \text{ Selected Pre-scaler}\\
	n = \text{ Timer 0, 1, 2}\\
	x = \text{ Comparison Module A, B}
\end{gathered}
$$

$$
\begin{gathered}
	\text{Phase Correct Frequency}\\
	f_{OCnx} = \frac{CK}{(2)(N)(TOP)}\\
	CK = \text{ Micro Clock Freq}\\
	N = \text{ Selected Pre-scaler}\\
	n = \text{ Timer 0, 1, 2}\\
	x = \text{ Comparison Module A, B}
\end{gathered}
$$

El PWM puede ser utilizado como un convertidor digital a analogico. Para una señal original de 0 a 5 voltios con un DC de 0.5 tenemos que:

$$
\begin{gathered}
	\text{Fourier Series of Periodic Signal}\\
	f(t) = \frac{V_0 t_1}{T} + a_1 \cos(2\pi ft) + a_3 \cos(6\pi ft) a_5 \cos(10\pi ft) + \dots \\
	f = \frac{5(1)}{2} + a_1 \cos(2\pi (2000)t) + a_3 \cos(6\pi (6000)t) a_5 \cos(10\pi (10000)t) + \dots \\
\end{gathered}
$$


## Problema 1 ##

```C
// Control the velocity of a motor conected through a transistor on PORTB.1 (OC1A).
// The reference must be read thorugh the 8 bit input of PORTD
```

## Problema 2 ##

```C
// Generate 4 signals PWM with FAST Mode of 50% in OCOA (PB6), 75% in OC0B (PD5), 90% OC2A (PB3), 10% OC2B (PD3)
```

## Problema 3 ##

```C
// Generate a sinusoidal signal of 100Hz on PORTD.6 (OC9A) using PWM for the digital analogue conversion.
// Generate a maximum frequency that allow PWM without PRE-Escaling
```

***

# ADC #

El proceso de digitalizacion en el microcontrolador es el de pasar de una señal analogica a una digital. Este proceso es necesario dado que la señal analogica es continua en el tiempo y en el voltaje por lo que se requiere un muestreo para poder ser interpretada de forma digital, es decir que el muestreo la convierte en una señal discreta. La cuantizacion es la division del espacio de voltaje y tiempo en un numero finito de valores aproximando las señales al nivel mas cercano y perdiendo ciertas propiedades de la señal original, en este paso a cada nivel de voltaje se le asigna un numero binario.

Para que el convertidor funcione es necesario establecer un reloj con preescalador, 50KHz a 200KHz para una resolucion maxima de 10 bits y mayor a 200KHz para una resolucion menor de 9 y 8 bits. El tiempo de conversion es de 13 a 260 microsegundos, con seis canales o pines multiplexados y un voltage de entrada de la señal analogica de 0 a Vcc. El voltaje de referencia seleccionable puede ser AVcc, AREF o 1.1V internos (Util para determinar la carga de la bateria de nuestro dispositivo.). Existen diversos modos de operacion del ADC, en todos ellos el bit ADEN o ADC Enable debe ser 1 logico:

1. Single Conversion Mode: Prender ADSC, esperar a que ADIF se prenda (fin conversion), leer ADCH y ADCL con el resultado y limpiar ADIF (escribir 1 logico).
1. Auto Trigger: Selecciona la fuente que iniciara la conversion (ADTS2, ADTS1, ADTS0), prender ADATE, se inicia la conversion mediante un flanco positivo de la fuente.
1. Free Running Mode: Seleccionar fuente de inicio 0, prender ADATE, para la primer conversion prender ADSC, al terminar la primer conversion inicia automaticamente con la siguiente.

| ADTS2 | ADTS1 | ADTS0 | Trigger Source |
| 0	| 0	| 0	| Free Running Mode | 
| 0	| 0	| 1	| Analog Comparator |
| 0	| 1	| 0	| External Interrupt Request 0 |
| 0	| 1	| 1	| Timer/Counter0 Compare Match |
| 1	| 0	| 0	| Timer/Counter0 Overflow |
| 1	| 0	| 1	| Timer/Counter 1 Compare Match B |
| 1	| 1	| 0	| Timer/Counter 1 Overflow |
| 1 | 1	| 1	| Timer/Counter 1 Event Catch |

Existe un multiplexor analogico integrado que permite seleccionar cualquiera de los 6 canales de entrada analogicos (ADC0 a ADC5 en PC0 a PC5). La seleccion del canal se realiza mediante los 4 bits (MUX0 a MUX3) del registro ADMEX.

* ADMUX (ADC Multiplexer Selection Register): Selecciona el canal y el voltaje de referencia.
* ADCSRA (ADC Control Status Register A): Habilita el ADC mediante ADEN e inicia la conversion mediante ADSC, tambier muestra el estatus de la conversion en ADIF y selecciona el reloj que utilizara en ADPS2 a ADPS0.
* ADCSRB (ADC Control Status Register B); Habilita la opcion de Auto Trigger del convertidor.
* ADCL y ADCH (ADC Data Register): 2 bytes que contienen el resultado de la conversion.
* DIDR0 (Digital Input Disable Register 0): Deshabilita la parte digital de un pin que se desea tener como analógico.

## Problema 1 ##

```C
// Using a LM35 sensor create a digital display of the temperature, use the internal 1.1 voltage as reference.
// Display the temperature each second in a DU.d format with a Centigrate character
```

## Problema 2 ##

```C
// Generate 6 PWM 8 bit signals that take as reference the value of 6 potentiometers
```

***

# Serial #

Creado inicialmente para conectar modems (moduladores y demoduladores) a las computadoras personales, introducida oficialmente en el estandar RS-232 de 1962 para la conexion entre computadoras mediante linea telefonica y poco despues para la conexion a internet. El puerto serial UART es un protocolo de comunicacion full duplex donde los bits de informacion se mandan uno a uno de forma seriada durante una comunicacion asincrona (sin reloj asignado), los dispositivos se ponen de acuerdo mediante velocidad (baud rate), numero de bits de datos, paridad, tamaño de bit de stop y mensajes para lograr la sincronizacion.

* Baud Rate (1/T): Establece la velocidad a la que se mandan los bits, expresada en bits por segundo. En la computadora se establece directamente como un valor de 110, 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 38400, 57600 o 115200 bps, en el microcontrolador se establece asignando la variable UBRR0.
* Numero de Bits: En la computadora se establece como señales de bits de 7 u 8. En el microcontrolador se establece como señales de 5, 6, 7, 8 o 9 bits.
* Bit de Paridad P: Ayuda a detectar un numero impar de bits como una señal de error en el mensaje. Paridad par implica que el numero de 1s en la señal (incluido este bit) es par, mientras que paridad impar implica que el numero de 1s (incluyendo a este bit) es non.
* Tamaño del Stop: Define el tamaño en terminos del tiempo por bit que tiene el bit de stop. En la computadora se establece como 1, 1.5 o 2, en el microcontrolador se establece como 1 o 2.
* Niveles de Voltaje: Determinan si el bit se asigna como 1 o 0 logico. En la computadora es 12 positivo y 12 negativo nominal mediante el rango de 2.5 a 25 V. En el microcontrolador es 5V a 0V (Vcc).

Por ejemplo:

1. Send character (1) = 0x31 = 0011 0001 = 1000 1100 
2. Idle (1) - Start Bit (0) - Message (1000 1100) - Stop Bit (1) - Idle (1)

Los registros UDR0 (UART Data Reg 0), UCSR0A (UART Control and Status Reg 0 A), UCSR0B, UCSR0C, UBRR0H y UBRR0L (UART Baud Rate Reg 0) se pueden definir mediante el codewisard the codevision siempre y cuando se establezca un error de baud menor al 2 porciento. La conexion fisica se realiza mediante cable microUSB a PC conectado con TX0 a RXD (PD0) y RXI a TXD (PD1). Para un acceso simple al puerto serial la libreria (stdio) cuenta con las siguientes funciones:

1. getchar: Lectura de un caracter (byte) del puerto serial.
1. putchar: Transmision de un caracter (byte) al puerto serial
1. printf: Transmision de un string con formato al puerto serial.
1. scanf: Lectura de un string del puerto serial.

## Problema 1 ##

```C
// Crete a program that recieves a char from serial port. If it is a number 0 to 9 display NUMBER else display OTHER
// Use Baud Rate of 9600 bps, 8 bits, 1 stop bit AT 1 MHz
```

## Problema 2 ##

```C
// Create a program that every seconds sends the number of seconds that had passed to the serial port.
// Also if it recieves a C or c character then the time must restart at 0
// Use Baud Rate of 19200, 8 bits, 1 stop bit AT 8 MHz
```

## Problema 3 ##

```C
// Determine the day of the week, asumming 1MHz, reciebe a date in format dd-mm-yyyy and return the day of the week
// Validate the separators as well as the numbers are in the expected ranges. Use Zellers algorithm.
// h = result (0=saturday, 1= sunday, 2=monday,), q = day of the month (dd), m = month (3 = may, 4 = april), Y year (yyyy)
// Using this formula January and February are the month number 13 and 14 of the previous year.
// The output is a string indicating the day of the week, use 9600 bps, 8 bit, 1 stop bit AT 1MHz
// h = (q + (((m+1)*26)/10) + Y + (Y/4) + (6*(Y/100)) + (Y/400)) % 7;
```

***

# Interrupciones #

Una interrupcion es un evento que suspende temporalmente la ejecucion del programa principal, al terminar su rutina se continua con la ejecucion del programa en el lugar en el que se quedo. Se utilizan para que un mismo programa ejecute multiples tareas. La rutina que se encarga de las interrupciones se denomina ISR (Interrupt Service Rutine). El registro de interrupciones globales es SREG. Para prender o apagar la interrupcion es necesario realizarlo por medio de las instrucciones SEI (Set Interrupt) y CLI (Clear Interrupt) que corresponden a definiciones ASM, ademas es necesario habilitar la interrupcion correspondiente mediante el registro que corresponde a cada fuente de interrupcion (25 fuentes).

El microcontrolador esta diseñado para recibir señales de interrupcion a los pines de interrupcion PCINTn (PCINT0 a PCINT23), mediante un cambio logico en su estado, observar que no se puede controlar que tipo de cambio es, flanco positivo (L to H), negativo (H to L) o en nivel bajo (L Pulse). En el pin PD2 y PD3 existen los unicos pines adaptados para interrupciones externas (INT0 y INT1) con direcciones (0x0002 y 0x0004) en donde se puede configurar el tipo de cambio que genera la interrupcion.

```C
interrupt [vector No] void name (void) { 
	// Interruption Code 
}
```

## Problema 1 ##

```C
// Create a periodic interrupt every second (Use Timer 1 of 16 bits in CTC MODE)
// Create a second timer with a 7 segment displey and a push to control start and stop
```

## Problema 2 ##

```C
// Modify the previous program using the Timer 0 (8 bits)
```

## Problema 1 ##

```C
// Unify the PacMan LCD problem and the MarioBros song using interrupts
```


## Problema 1 ##

```C
// Simulate a stoplight using a DUAL 7 segment display
// At the start by defaul green light (cars) and red light (people), stay at this state until button pressed
// If push is pressed then go to yellow (cars) for 2 sec and then to red. If light (cars) is red turn to green (people)
// If green people start timer of 20 sec visible on the dual display. Ignore further presses of the button.
// After 20 sec go to green light (cars) and red light (people), continue ignoring further presses for another 20 sec.
// When the clock is running generate a 440Hz sound every second with a duration of 250 msec

```

***

# Secure Digital SD #

La tecnologia Secure Digital SD es un tipo de memoria no volatil FLASH desarrollada en 1999 por SanDisk, Matsushita y Toshiba como MMC, siendo la principal competencia del MemoryStick de Sony de 1998. El nombre de Secure proviene de su capacidad para almacenar contenido que solo puede ser leido por dispositivos autorizados, en 2003 se crea miniSD y en 2006 la microSD. El sistema de archivos del sistema es un metodo para el almacenamiento y organizacion de informacion mediante una base de datos. Entre los mas conocidos se encuentra FAT (12, 16, 32, ex), NTFS, HFS (Plus, HPFS), UFS, ext2, ext3, ext4, btrfs y ISO9660. Compartir el mismo sistema de archivos permite la interoperabilidad entre dispositivos.

* SD: Tradicional para tarjetas de 2GB con sistemas de archivos FAT16 y FAT32 (File Allocation Table)
* SDHC: SD High Capacity para tarjetas con capacidades de 4GB hasta 32 GB, sistema de archivos FAT32
* SDXC: SD con capacidad extendida para capacidades de 64GB a 2TB con sistema de archivos nativo exFAT

Su alimentacion es de 2.7V a 3.6V, por lo que se recomienda utilizarlas con un regulador de 3.3V, si se conecta a un microcontrolador existe la posibilidad de alimentar al microcontrolador con la misma fuente de 3.3 V. Las Tarjetas SD se pueden comunicar por medio de distintos protocolos:

* SPI (Serial Peripheral Interface): Utilizada por sistemas basados en microcontroladores.
* One Bit SD: Comandos y datos se mandan por canales distintos mediante protocolo propietario.
* Four Bit SD: Exclusivo de memorias SDHC y SDXC utiliza voltaje de 1.8V para transferencias de mayor capacidad.

***

# WAV #

El formato WAV es el estandar de microsoft para digitalizar sonido, creado para Windows 3.1 como un archivo binario con 58 bytes de encabezado y un area de datos. El encabezado contiene el tamaño de la muestra (8, 16, 32 bits), el numero de canales (1 mono, 2 estereo), la frecuencia de muestreo (8000, 11025, 22050, 44100 Hz), el formato de digitalizacion (PCM, ALow, uLaw, GSM, etc), el tamaño del archivo y el numero total de muestras.

* Calidad Telefono: PCM, mono, 8 bits, 11025 Hz.
* Calidad Radio: PCM, mono, 8 bits, 22050 Hz.
* Calidad CD: PCM, estereo, 16 bits, 44100 Hz.

 ```c
// WAV HEADER
// File Size (size) = F, No. Channels (nChannels) = C, No. Samples (nSamplesPerSec) = S, No. Bytes (nAvgBytesPerSec) = B
// Sample Bytes per No. Channel (nBlockAlign) = P, No. Total Samples = T, Data = D

0000 = 'R' 'I' 'F' 'F' FFF FFF FFF FFF 'W' 'A' 'V' 'E' 'f' 'm' 't'  20
0010 =  12  00  00  00  01  00 CCC CCC SSS SSS SSS SSS BBB BBB BBB BBB
0020 = PPP PPP  10  00  00  00 'f' 'a' 'c' 't'  04  00  00  00  2C  FC
0030 =  14  00 'd' 'a' 't' 'a' TTT TTT TTT TTT DDD DDD DDD DDD DDD DDD

// EXAMPLE WAV Mono, 16 bytes per sample, PCM, 44100 Hz, 926668 samples, 21 seconds total

0000 =  52  49  46  46  FE  23  0E  00  57  41  56  45  66  6D  74  20
0010 =  12  00  00  00  01  00  01  00  44  AC  00  00  88  58  01  00
0020 =  02  00  10  00  00  00  66  61  63  74  04  00  00  00  E6  11
0030 =  07  00  64  61  74  61  CC  23  03  00  A7  D1  82  DD  59  59

// FE230E, 0100, 44AC0000, 88580100, 0200, CC230300
// E23FE,  1, AC44, 15888, 2, E23CC
// Size = E23FE = (926718 bytes), No. Channels = 0001, No Samples = AC44 (44100 Hz), No. Bytes = 15888 (88200)
// 1 Channel * 2 Bytes per Sample * 44100 samples per second = 88200
// Bytes per Sample = 0002, Total Smples = E23CC = 926668

```


Una melodia se puede reproducir en el microcontrolador mediante una coneccion SD con un adaptador PJRC, socket, buffer y regulador de 3.3V. Mediante 3 bits de seleccion se puede reproducir A001.WAV - A008.WAV. Para ello los audios deben de tener el formato WAV PCM, 22050 KHz, 8 bit, Monoaural. 

***

# Features #

Microchip PIC16F84A - 18-Pin Enhanced FLASH/EEPROM 8-bit Microcontroller

The product code is part, frequency, temperature, package and pattern. For example `PIC16F84A` -04C/P 301 is a 4 MHz (-04), Commercial temperature from 0 to 70 (C), PDIP packaging (/P), QTP pattern 301 with normal VDD limits (F). Other options include extended VDD (LF), tape and reel SOIC configuration (T), industrial temperature from -40 to 85 (I), SOIC package (SO) and SSOP package (SS).

1. High Performance RISC CPU with 35 single word instructions
2. All instructions are single cycle except for program branches
3. 20 MHz DC clock input for a 200 ns instruction cycle
4. 1024 words of program memory
5. 68 bytes of RAM
6. 64 bytes of EEPROM
7. 14 bit instruction words
8. 15 Special Function Hardware registers
9. 8 Level Deep hardware stack
10. Direct, indirect and relative addressing modes
11. Not suitable for critical life support systems
12. Includes integrated code security and protection
13. Four interrupt sources:
    1.  RBO/INT pin, TMR0 timer overflow, PORTB 7-4 on charge, EEPROM write complete.
14. 13 I/O bidirectional pins
15. High current sink and source for direct LED drive (25 mA max per pin)
16. 8 bit timer-counter TMR0 with 8 bit prescaler.
17. 10K Erase/Write Enhanced FLASH and 10M Erase/Write EEPROM cycles.
18. 2V (32kHz 15A) to 5V (4 MHz 2mA) operating range to VDD
19. In Circuit Serial Programming (ICSP), Power on Reset (POR), Power up Timer (PWRT).
20. Oscillator Startup Timer (OST), Watchdog Timer (WDT), SLEEP power saving mode.

# Pins #

| Name | PDIP - SOIC | SSOP | I/O/P | Buffer | Notes | 
| :--- | :--- | :--- | :--- | :--- | :--- |
| RA2 Pin | 1 | 1 | I/O | TTL | PORTA are bidirectional I/O ports |
| RA3 Pin | 2 | 2 | I/O | TTL | PORTA are bidirectional I/O ports |
| RA4 Pin / T0CKI | 3 | 3 | I/O | ST | PORTA are bidirectional I/O ports, can be used as clock input for TMR0. 12V Open drain output. |
| MCLR | 4 | 4 | I/P | ST | Master Clear or Reset programming voltage, active low Reset pin to the device |
| VSS | 5 | 5,6 | P |  | Ground Reference for Pins |
| RB0 / INT | 6 | 7 | I/O | TTL/ST | PORTB are bidirectional I/O ports, can be programmed as internal weak pull-up on all inputs. Can be selected as an external interrupt pin. |
| RB1 | 7 | 8 | I/O | TTL | PORTB are bidirectional I/O ports, can be programmed as internal weak pull-up on all inputs |
| RB2 | 8 | 9 | I/O | TTL | PORTB are bidirectional I/O ports, can be programmed as internal weak pull-up on all inputs |
| RB3 | 9 | 10 | I/O | TTL | PORTB are bidirectional I/O ports, can be programmed as internal weak pull-up on all inputs |
| RB4 | 10 | 11 | I/O | TTL | PORTB are bidirectional I/O ports, can be programmed as internal weak pull-up on all inputs. Interrupt on charge pin. |
| RB5 | 11 | 12 | I/O | TTL | PORTB are bidirectional I/O ports, can be programmed as internal weak pull-up on all inputs. Interrupt on charge pin. |
| RB6 | 12 | 13 | I/O | TTL/ST | PORTB are bidirectional I/O ports, can be programmed as internal weak pull-up on all inputs. Interrupt on charge pin and serial programming clock. |
| RB7 | 13 | 14 | I/O | TTL/ST | PORTB are bidirectional I/O ports, can be programmed as internal weak pull-up on all inputs. Interrupt on charge pin and serial programming data. |
| VDD | 14 | 15,16 | P |  | Positive Voltage Supply for Pins |
| OSC2 / CLKOUT | 15 | 17 | O |  | Oscillator Crystal or Resonator Output. In RC mode outputs 1/4 the freq. of OSC1 (cycle rate). |
| OSC1 / CLKIN | 16 | 18 | I | ST/CMOS | Oscillator Crystal input or external clock source |
| RA0 | 17 | 19 | I/O | TTL | PORTA are bidirectional I/O ports |
| RA1 | 18 | 20 | I/O | TTL | PORTA are bidirectional I/O ports |

Where TTL means TTL Input and ST means Schmitt Trigger input.

* OSC1 (15) and OSC2 (16) go to the timing generator.
* MCLR (4), VDD (14) and VSS (5) go to the PWRT, OST, POR and WDT stack. 
  * This communicates with the timing generator and the Instruction Decoder and Controller.
* RA4 Pin / TOCKI goes to the TMR0 communicating with the rest of the microcontroller.
  * STATUS reg, FSR reg, MUX, ALU, W reg, Addr Mux, RAM reg (68 x 8), Program Counter and EEPROM.
  * EEPROM has EEDATA, Data Memory (64 x 8) and EEADR. Program Counter has the 8 Level Stack (13bit).
* Program Counter goes to FLASH (1k x 14) and to the Instruction Reg.

# Memory #

* Memory is composed of program memory and data memory blocks with independent buses.
* Program Memory uses the 13-bit counter (8 level-stack) capable of addressing 8k x 14 memory space.
  * CALL, RETURN, RETFIE, RETLW
  * The first 1k x 14 (0000h - 03FFh) are physically implemented (User Memory Space).
  * 0000h (Reset Vector) and 0004h (Peripheral Interrupt Vector) are located here.
  * Addressing a location above 03FFh will cause a wraparound.
* Data Memory can be divided into general purpose static RAM (GPR) and Special Function Registers (SFRs).
  * EEPROM memory (0h to 3Fh) can be indirectly accessed through pointers from the Data Memory block.
  * SFRs control the device operation, meaning CPU (core set) and Peripheral functions (peripheral set).
  * Both GPR and SFTs are banked using control selection bits from the STATUS register.
  * GPR area is banked to allow for greater than 116 bytes while SFTs is banked for peripheral function registers.
  * Instructions `MOVWF` and `MOVF` can move values from the W reg to any F reg (File) and vice-versa.
  * Data memory can be accessed using direct or indirect addressing.
* Direct addressing uses the absolute address of each register file.
* Indirect addressing uses the File Select Register (FSR) and the value of the RP0 bank selector bit.
  * Bank 0 is selected by clearing RP0 (STATUS 5) and Bank 1 by setting RP0.
  * Each bank is 128 bytes (7Fh and FFh) with the first twelve locations reserved for SFRs.
  * Note that GPR Bank locations are equivalent, for example 8Ch (Bank 1 GPR) actually points to 0Ch (Bank 0 GPR).

# Special Function Registers #

| Address Bank 0 | Name | Bit 7 | Bit 6 | Bit 5 | Bit 4 | Bit 3 | Bit 2 | Bit 1 | Bit 0 | Reset Value |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |  
| 03h | STATUS | IRP | RP1 | RP0 | TO | PD | Z | DC | C | 0001 1xxx |
| 05h | PORTA |  |  |  | RA4 | RA3 | RA2 | RA1 | RA0 | ---x xxxx |
| 06h | PORTB | RB7 | RB6 | RB5 | RB4 | RB3 | RB2 | RB1 | RB0 | xxxx xxxx |
| 0Bh | INTCON | GIE | EEIE | T0IE | INTE | RBIE | T0IF | INTF | RBIF | 0000 000x |

| Address Bank 0 | Name | Description | Reset Value |
| :--- | :--- | :--- | :--- |
| 00h | INDF | Uses FSR to access Data Memory (Not Physical Reg) | ---- ---- |
| 01h | TMR0 | 8 Bit Real Time Clock (Counter) | xxxx xxxx |
| 02h | PCL | Low Order 8 bit Program Counter (PC) | 0000 0000 |
| 04h | FSR | Indirect Data Memory Pointer 0 | xxxx xxxx |
| 07h | - | Unimplemented (0) | - |
| 08h | EEDATA | EEPROM Data Register | xxxx xxxx |
| 09h | EEADR | EEPROM Address Register | xxxx xxxx |
| 0Ah | PCLATH | Write Buffer for the PC using upper 5 bits  | ---0 0000 |

| Address Bank 1 | Name | Bit 7 | Bit 6 | Bit 5 | Bit 4 | Bit 3 | Bit 2 | Bit 1 | Bit 0 | Reset Value |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |  
| 81h | OPTION_REG | RBPU | INTEDG | T0CS | T0SE | PSA | PS2 | PS1 | PS0 | 1111 1111 |
| 83h | STATUS | IRP | RP1 | RP0 | TO | PD | Z | DC | C | 0001 1xxx |
| 88h | EECON1 |  |  |  | EEIF | WRERR | WREN | WR | RD | ---0 x000 |
| 0Bh | INTCON | GIE | EEIE | T0IE | INTE | RBIE | T0IF | INTF | RBIF | 0000 000x |

| Address Bank 1 | Name | Description | Reset Value |
| :--- | :--- | :--- | :--- |
| 80h | INDF | Uses FSR to access Data Memory (Not Physical Reg) | ---- ---- |
| 82h | PCL | Low Order 8 bit Program Counter (PC) | ---- ---- |
| 84h | FSR | Indirect Data Memory Pointer 0 | ---- ---- |
| 85h | TRISA | PORTA Data Direction Register using upper 5 bits | ---- ---- |
| 86h | TRISB | PORTB Data Direction Register | ---- ---- |
| 87h | - | Unimplemented (0) | ---- ---- |
| 89h | EECON2 | EEPROM Control Register 2 (Not Physical Reg) | ---- ---- |
| 0Ah | PCLATH | Write Buffer for the PC using upper 5 bits  | ---- ---- |

1. PCLATH is a slave of PC 12:8 , its contents can be transferred to the PC but they can't be transferred from the PC to PCLATH. Note that in STATUS the bits TO and PD aren't affected by a MCLR Reset. Other non Power Up Resets include MCLR and WDT, also PORTA will be set as inputs and PORTB will be transferred to the Port Output Latch on Reset.

For direct addressing select the Bank with RP1 and RP0 and then 7 bits (from 6 to 0) of the OPCODE as the location. For indirect addressing select the Bank with IRP and then 8 bits (from 7 to 0) of the FSR as the location.

## STATUS Register ##

Contains the status of the ALU, RESET and the Bank Select Bit. The TO and PD bits are non-writable. Some instructions on STATUS affect the Z, DC or C bits and will prevent writing to them, for example `CLRF STATUS` will produce `000u u1uuu` with (u) as the unaffected bits. It is heavily recommended to only use the instructions `BCF`, `BSF`, `SWAPF` and `MOVWF` with this register.

1. IRP (R/W-0): This bit isn't implemented, maintain as 0.
2. RP1 (R/W-0): This bit isn't implemented, maintain as 0.
3. RP0 (R/W-0): Register Bank select Bit (Direct Addressing). Select Bank 0 with (00) or select Bank 1 with (01).
4. TO (R-1): Time Out Bit. By default (1) after power-up, CLRWDT or SLEEP. Goes to (0) after a WDT Time Out.
5. PD (R-1): Power Down Bit. By default (1) after power-up or CLRWDT. Goes to (0) after SLEEP.
6. Z (R/W-x): Is (1) if the arithmetic or logic operation returns zero else goes to (0) if it returns a non-zero result.
7. DC (R/W-x): Digit Carry Bit when using (ADDWF, ADDLW, SUBLW, SUBWF). Set to (1) after a carry-out from the 4th low order bit else goes to (0).
8. C (R/W-x): Carry Bit when using (ADDWF, ADDLW, SUBLW, SUBWF). Set to (1) after a carry-out from the most significant bit else goes to (0).

## OPTION Register ##

Contains bits to configure the TMR0 and WDT Prescaler, INT interrupt and PORTB weak pull-ups.

1. RBPU (R/W-1): Disable all PORTB Pull-Ups if (1), else enable individual PORTB latch values.
2. INTEDG (R/W-1): Interrupt Edge Select Bit. If set (1) then interrupt on rising edge of RB0/INT, else interrupt on falling edge.
3. T0CS (R/W-1): TMR0 Clock Source Select Bit. If set (1) then transition to RA4 pin, else use CLKOUT the internal instruction cycle clock.
4. T0SE (R/W-1): TMR0 Source Edge Select Bit. If set (1) then increment counter on high to low transition of RA4, else increment on low to high.
5. PSA (R/W-1): Prescaler Assignment Bit. If set (1) the prescaler is assigned to WDT (TMR0 has a 1 rate), else it's assigned to the TMR0 module.
6. PS2 (R/W-1): Prescaler Rate Select Bit. 
7. PS1 (R/W-1): Prescaler Rate Select Bit.
8. PS0 (R/W-1): Prescaler Rate Select Bit.

Prescaler Select Bit for WDT Rate (denominator) is 1 (000), 2 (001), 4 (010), 8 (011), 16 (100), 32 (101), 64 (110), 128 (111). For TMR0 Rate is 2 (000), 4 (001), 8 (010), 16 (011), 32 (100), 64 (101), 128 (110), 256 (111).

## INTCON Register ##

Contains bits for all interrupt sources. The interrupt flag bits are set (1) when their interrupt condition happens regardless of their corresponding enable bit or global enable bit (GIE).

1. GIE (R/W-0): Global Interrupt Enable Bit.
2. EEIE (R/W-0): EE Write Complete Interrupt Enable Bit. Set (1) to enable all unmasked Interrupt Conditions, else they are disabled.
3. T0IE (R/W-0): TMR0 Overflow Interrupt Enable Bit. Set (1) to enable TMR0 Overflow interrupt, else it's disabled.
4. INTE (R/W-0): RB0/INT External Interrupt Enable Bit. Set (1) to enable RB0/INT external interrupt, else it's disabled.
5. RBIE (R/W-0): RB Port Change Interrupt Enable Bit. Set (1) to enable RB port change interrupt, else it's disabled.
6. T0IF (R/W-0): TMR0 Overflow Interrupt Flag Bit. By default (0) but set to (1) if TMR0 Overflow occurred (Must be cleared in Software).
7. INTF (R/W-0): RB0/INT External Interrupt Flag Bit. By default (0) but set to (1) if RB0/INT external interrupt occurred (Must be cleared in Software).
8. RBIF (R/W-x): RB Port Change Interrupt Flag Bit. By default (0) but set to (1) if at least one RB7-RB4 pin changed state (Must be cleared in Software).

## PCL, PCLATH, STACK, INDF, FSR ##

The program counter (PC) or stack of 13 bits (8 level deep) contain the addresses of the instructions to fetch for execution. Its low byte is the PCL register and its high byte is the PCH register. If PC is modified or a conditional test returns true then the instruction requires two cycles (Second is NOP).

* Every update goes to the PCH register from the PCLATH register.
* The PC is PUSHED onto the stack after a CALL is executed or an interrupt causes a branch.
* The Stack is POPED after a RETURN, RETLW or RETFIE is executed. 
* After a PUSH or POP the PCLATH isn't modified.
* If the stack is PUSHED 8 times the next time it'll overwrite the value from the first push.
* INDF is not a physical register but a pointer to the address contained in FSR (Indirect Addressing).

For example, suppose the register (05) has a value of (10h) and the register (06) has a value of (0Ah), we load the value of (05) into FSR. If we read the INDF register it will return (10h), if we increment FSR into (06) then when we read INDF it will return (0Ah). Trying to read INDF itself with FSR (0) will give (00h). Another example of indirect addressing to clear RAM locations is:

```bash
movlw 0x20; initialize pointer
movwf FSR; to RAM
NEXT 
clrf INDF; clear INDF register
incf FSR; inc pointer
btfss FSR,4; all done?
goto NEXT; if NO, clear next
CONTINUE:; if YES, continue
```

# EEPROM Memory #

EEPROM data memory is readable and writable during operation, the memory is not mapped directly into the register file space addressed only through the Special Function Registers: EECON1, EECON2 (non-physical), EEDATA and EEADR. EEDATA holds 8-bit data for transfer and EEPROM the location being accessed.  A byte write operation overwrites the data and is rated for a high number of cycles. The bits on the control register (EECON1 and EECON2) are:

1. Unimplemented (U-0): Read as 0.
2. Unimplemented (U-0): Read as 0.
3. Unimplemented (U-0): Read as 0.
4. EEIF (R/W-0): Write Operation Interrupt Bit. If set (1) the write operation completed successfully, else it hasn't completed or hasn't started.
5. WRERR (R/W-x): Error Flag Bit. If set (1) the write operation was terminated (MCLR or WDT reset), else it completed without errors.
6. WREN (R/W-0): Write Enable Bit. If set (1) allows write cycles, else it inhibits the write operation.
7. WR (R/S-0): Write Control Bit. If set (1) it initiates a write cycle and then it's cleared automatically, else the write cycle finished.
8. RD (R/S-x): Read Control Bit. If set (1) it initiates a read cycle and then it's cleared automatically, else the read cycle isn't initialized.

To read a data memory location you must write the address to the EEADR register and set the RD bit, EEDATA holds the data until written to by the user or read:

```bash
BCF STATUS, RP0 ; Bank 0
MOVLW CONFIG_ADDR ;
MOVWF EEADR ; Address to read
BSF STATUS, RP0 ; Bank 1
BSF EECON1, RD ; EE Read
BCF STATUS, RP0 ; Bank 0
MOVF EEDATA, W ; W = EEDATA
```

To write to a data memory location you must write the address to the EEADR register and the data to the EEDATA register, note the sequence of operations to fill each byte, it's recommended to disable interrupts during write operations:

```bash
BSF STATUS, RP0 ; Bank 1
BCF INTCON, GIE ; Disable INTs.
BSF EECON1, WREN ; Enable Write
MOVLW 55h ;
MOVWF EECON2 ; Write 55h
MOVLW AAh ;
MOVWF EECON2 ; Write AAh
BSF EECON1,WR ; Set WR bit
BSF INTCON, GIE ; Enable INTs.
```

WREN in EECON1 must be set to enable write, this is to prevent accidental writes due to unexpected execution, in other words WREN must be clear at all times except when updating the EEPROM memory. The WR is cleared and EEIF is set automatically at the end of the write cycle. You must clear the EEIF bit manually. EEDATA (08h), EEADR (09h), EECON1 (88h) and EECON2 (89h) are the relevant addresses.

# Ports #

Some pins are multiplexed with alternate functions, in general when a peripheral is enabled then the pin can't be used as a general purpose I/O pin. PORTA is a 5-bit bi-directional port with TRISA as it's data direction register. If a TRISA bit is set (1) then the corresponding PORTA pin will be set as INPUT (Output driver set to High Impedance) in a similar way if cleared the corresponding PORTA pin will be set as OUTPUT (Contents of the latch put on the pin). 

By default (power-on RESET) the pins are set as INPUTS and read as 0. The pin RA4 is multiplexed with the Timer0 Module Clock making it a Schmitt Trigger input and an open drain output, every other RA pin have TTL input and CMOS output drivers. To initialize the PORTA:

```bash
BCF STATUS, RP0 ;
CLRF PORTA ; Initialize PORTA by clearing output data latches
BSF STATUS, RP0 ; Select Bank 1
MOVLW 0x0F; Value used to initialize data direction
MOVWF TRISA ; Set RA 3:0 as inputs RA4 as output
```

| Address | Name | Bit 7 | Bit 6 | Bit 5 | Bit 4 | Bit 3 | Bit 2 | Bit 1 | Bit 0 | Reset Value |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |  
| 05h | PORTA |  |  |  | RA4/T0CKI | RA3 | RA2 | RA1 | RA0 | ---x xxxx |
| 85h | TRISA |  |  |  | TRISA4 | TRISA3 | TRISA2 | TRISA1 | TRISA0 | ---1 1111 |

PORTB is an 8-bit port that works in a similar way to PORTB with its corresponding TRISB. RB0, RB6 and RB7 are Schmitt Trigger because of the external interrupt and the serial programming clocks. The pins of PORTB have a weak internal pull-up, a single control bit can turn on all the pull-ups (clearing RBPU). This pull-up is cleared automatically when the pin is configured as an output and disabled completely on a Power-On RESET. 

The pins RB4, RB5, RB6 and RB7 have an Interrupt-On-Change feature that can be used when set as inputs. In this mode the pins compare the old value latched from the last PORTB read, any mismatch are OR'ed together to generate the RB Port Change Interrupt Flag Bit (RBIF) from the INCON register. To clear the interrupt from the Interrupt Service Routine you can read or write from PORTB (ending the mismatch) or clear the RBIF flag. This interrupt feature is recommended for Wake-Up from SLEEP on the device. To initialize PORTB:

```bash
BCF STATUS, RP0 ;
CLRF PORTB ; Initialize PORTB by clearing output data latches
BSF STATUS, RP0 ; Select Bank 1
MOVLW 0xCF ; Value used to initialize data direction
MOVWF TRISB ; Set RB 3:0 as inputs RB 5:4 as outputs RB 7:6 as inputs
```

| Address | Name | Bit 7 | Bit 6 | Bit 5 | Bit 4 | Bit 3 | Bit 2 | Bit 1 | Bit 0 | Reset Value |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |  
| 06h | PORTB | RB7 | RB6 | RB5 | RB4 | RB3 | RB2 | RB1 | RB0/INT | xxxx xxxx |
| 86h | TRISB | TRISB7 | TRISB6 | TRISB5 | TRISB4 | TRISB3 | TRISB2 | TRISB1 | TRISB0 | 1111 1111 |
| 81h | OPTION_REG | RBPU | INTEDG | T0CS | T0SE | PSA | PS2 | PS1 | PS0 | 1111 1111 |
| 0Bh,8Bh | INTCON | GIE | EEIE | T0IE | INTE | RBIE | T0IF | INTF | RBIF | 0000 000x |

# Timer0 #

The Timer0 module is an 8-bit timer and counter, readable and writable, with an 8-bit prescaler, internal or external (edge select) clock select and an Interrupt-On-Overflow. Timer mode is selected by clearing T0CS, in this mode the module increments every instruction cycle, note that if written the increment will be inhibited for two cycles. Counter mode is selected by setting T0CS, in this mode the module increments after every rising or falling edge of the pin RA4, the edge select is configured by the T0SE bit. When an external clock input is used it must be synchronized with the internal phase clock with an inevitable delay. 

An 8-bit counter is available as a prescaler for Timer0 or a postscaler for WDT. The prescaler is shared by Timer0 and WDT, this is not readable or writable. The PSA, PS2, PS1, PS0 control the prescaler assignment and ratio, for example clearing PSA assigns the prescaler to the Timer0 module, in this mode values of 1 to 228 are selectable. When used for the Timer0 every write operation (CLRF, MOVWF, BSF, etc) will clear the prescaler, when used for the WDT a CLRWDT will clear the prescaler. A TMR0 interrupt is generated after an overflow from FFh to 00h setting the bit T0IF, this interrupt can be masked by clearing T0IE. Note that this interrupt can't wake from SLEEP since it shuts-down during SLEEP.

# Special Features #

This microcontroller has many special features designed to deal with real time applications, providing reliability, code protection, cost reduction and power saving modes.

1. OSC Selection (Oscillator Configuration)
2. RESET (POR, PWRT, OST)
3. Interrupts
4. Watchdog Timer WDT
5. SLEEP
6. Code Protection
7. ID Locations
8. In-Circuit Serial Programming ICSPTM

Configuration bits can be programmed (0) or unprogrammed (1) to select the desired configuration. The bits are mapped to the address (2007h), the address is beyond the user program memory inside the special test memory space (2000h - 3FFFh) which can only be accessed during the programming phase.

1. Bits 13 to 4 (R/P-u): Code Protection Bit. If set (1) then conde protection is disabled, else all memory is code protected.
2. PWRTE (R/P-u): Power Up Timer Enable Bit. If set (1) the power-up timer is disabled, else its enabled.
3. WDTE (R/P-u): Watchdog Timer Enable Bit. If set (1) the watchdog timer is disabled, else its enabled.
4. FOSC1 (R/P-u): Oscillator Selection Bit. If (11) select RC OSC, if (10) select HS OSC, if (01) select XT OSC, else (00) select LP OSC.
5. FOSC0 (R/P-u):  Oscillator Selection Bit. 

## OSC Selection ##

The PIC has 4 oscillator modes: LP Low Power Crystal Mode, XT Crystal-Resonator Mode, High Speed Crystal Resonator Mode and Resistor-Capacitor Mode. In every mode except RC we will connect an external crystal or ceramic resonator to OSC1/CLKIN pin and to OSC2/CLKOUT pin. The ceramic capacitors used for the crystal range from 15 to 33 pF, generally for frequencies higher than 4MHz the HS mode is recommended over the default XT mode. For time insensitive applications the RC option offers additional cost savings.

## RESET ##

The PIC has multiple RESET conditions: 

1. Power-On RESET (POR)
2. MCLR during Operation
3. MCLR during SLEEP
4. WDT RESET during Operation
5. WDT RESET during SLEEP

Note that the MCLR reset has a noise filter to prevent a RESET from small pulses. There are many registers unaffected from any RESET where their values remain unknown. The TO and PD bits are set or cleared differently based on the RESET since they are linked to the specific RESET used. 

TABLAS DE RESET

The Oscillator Start-Up Timer offers a delay on power-up, used to keep the chip in RESET mode until the crystal is stable.
The Power-Up Timer provides a fixed delay on power-up of 72 ms to keep the chip in RESET mode until the power supply stabilizes.

## Interrupts ##

## Watchdog Timer ##

The WDT can only be shut-off through the configuration bits since it uses its own RC oscillator for increased reliability. 


## Sleep ##

The SLEEP mode offers low current power-down, waking up through an external RESET, WDT or an Interrupt. 

## Code Protection ##

## ID Locations ##

## ICSPTM ##

The four memory locations (2000h - 2004h) are designated as ID locations used for checksum storage and aren't accessible during operation

# Instruction Set #

14 bit words with an OPCODE and one or more operands (Fields) were the first 2 bits are the MSb. The instructions can be classified into byte oriented (OPCODE - Field - Address), bit oriented (OPCODE - Field - Address) or literal-control (OPCODE - Literal) operations. All take one instruction cycle with the exception of conditional tests and program counter changes that take two (The second is a `NOP`). One instruction cycle takes 4 oscillator periods therefore  for a 4 MHz oscillator the normal instruction execution takes 1 microsecond.

| Field | Description |
| :--- | :--- |
| f | Register File Address (From 0x00 to 0x7F) | 
| W | Working Register (Accumulator) | 
| b | Bit within an 8 bit file register | 
| k | Literal, constant or label | 
| x | Don't care location, can be 0 or 1 | 
| d | Destination selection, if 0 store in (W), if 1 store in (f) | 
| PC | Program Counter | 
| TO | Time Out Bit | 
| PD | Power Down Bit | 

* If (d) is 0 store the result in (W) else if (d) is 1 store the result in (f)

Byte Oriented

| Programming Operand | Description | Cycles | OPCODE | Status |
| :--- | :--- |  :--- |  :--- |  :--- |
| NOP f,d | No Operation | 1 | 00 0000 0xx0 0000 | |
| MOVWF f | Move W to f | 1 | 00 0000 lfff ffff | |
| CLRW | Clear W, Z bit is set (Zero Bit) | 1 | 00 0001 0xxx xxxx | Z |
| CLRF f | Clear f, Z bit is set | 1 | 00 0001 lfff ffff | Z |
| SUBWF f,d | Substract W from f, uses 2s complement method | 1 | 00 0010 dfff ffff | C,DC,Z |
| DECF f,d | Decrement f | 1 | 00 0011 dfff ffff | Z |
| IORWF f,d | Inclusive W OR f conditional | 1 | 00 0100 dfff ffff | Z |
| ANDWF f,d | W AND f | 1 | 00 0101 dfff ffff | Z |
| XORWF f,d | Exclusive W OR f conditional | 1 | 00 0110 dfff ffff | Z |
| ADDWF f,d | Add W to f | 1 | 00 0111 dfff ffff | C,DC,Z |
| MOVF f,d | Move f, if d is 0 move to W else move to f | 1 | 00 1000 dfff ffff | |
| COMF f,d | Complement f | 1 | 00 1001 dfff ffff | Z |
| INCF f,d | Increment f | 1 | 00 1010 dfff ffff | Z |
| DECFSZ f,d | Decrement f but Skip if 0 | 1,2 | 00 1011 dfff ffff | |
| RRF f,d | Rotate Right f (carry), rotate one bit using the carry flag | 1 | 00 1100 dfff ffff | C |
| RLF f,d | Rotate Left f (carry), rotate one bit using the carry flag | 1 | 00 1101 dfff ffff | C |
| SWAPF f,d | Swap nibbles in f | 1 | 00 1110 dfff ffff | |
| INCFSZ f,d | Increment f but Skip if 0 | 1,2 | 00 1111 dfff ffff | |

Bit Oriented

| Programming Operand | Description | Cycles | OPCODE | Status |
| :--- | :--- |  :--- |  :--- |  :--- |
| BCF f,b | Clear Bit b from f | 1 | 01 00bb bfff ffff | |
| BSF f,b | Set Bit b from f | 1 | 01 01bb bfff ffff | |
| BTFSC f,b | If b from f is 1 run next instruction, else ignore next and execute NOP instead. | 1,2 | 01 10bb bfff ffff | |
| BTFSS f,b | If b from f is 0 run next instruction, else ignore next and execute NOP instead. | 1,2 | 01 11bb bfff ffff | |

Literal Oriented

| Programming Operand | Description | Cycles | OPCODE | Status |
| :--- | :--- |  :--- |  :--- |  :--- |
| RETURN | Return from Subroutine, stack is POPed and TOS is loaded into PC | 2 | 00 0000 0000 1000 | |
| RETFIE | Return from an Interrupt | 2 | 00 0000 0000 1001 | |
| SLEEP | Standby Mode, PD is cleared, TO is set, WDT and its prescaler are cleared, the oscillator is stopped | 1 | 00 0000 0110 0011 | TO, PD |
| CLRWDT | Clear Watchdog Timer by setting TO and PD, also it resets its prescaler | 1 | 00 0000 0110 0100 | TO, PD |
| CALL k | Call a Subroutine k, return address PC+1 is loaded into the PC stack and upper PC bits are from PCLATH | 2 | 10 0kkk kkkk kkkk | |
| GOTO k | Go to Address k, | 2 | 10 1kkk kkkk kkkk | |
| MOVLW k | Move k to W, don't cares x are assembled as 0 | 1 | 11 00xx kkkk kkkk | |
| RETLW k | Return with k in W, the PC is loaded from the TOS | 2 | 11 01xx kkkk kkkk | |
| IORLW k | Inclusive W OR k conditional, store in W | 1 | 11 1000 kkkk kkkk | Z |
| ANDLW k | W AND k, store in W | 1 | 11 1001 kkkk kkkk | Z |
| XORLW k | Exclusive W OR k conditional, store in W | 1 | 11 1010 kkkk kkkk | Z |
| SUBLW k | Subtract W from k, uses 2s complement method, store in W | 1 | 11 110x kkkk kkkk | C, DC, Z |
| ADDLW k | Add W to k, store in W | 1 | 11 111x kkkk kkkk | C, DC, Z |

***

